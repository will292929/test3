<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Visual GitHub Pages Editor</title>
  <style>
.iframe-wrapper {
  position: relative;
  display: inline-block;
  overflow: hidden;
}
.iframe-overlay {
  position: absolute;
  top: 0; left: 0;
  width: 100%; height: 100%;
  background: transparent;
  z-index: 1000;
  cursor: pointer;
}
.edit-backdrop {
  position: fixed;
  top: 0; left: 0;
  width: 100vw; height: 100vh;
  background: rgba(0,0,0,0.3);
  z-index: 1999;
}
.edit-overlay {
  position: fixed;
  top: 50%; left: 50%;
  transform: translate(-50%, -50%);
  background: white;
  border: 1px solid #ccc;
  padding: 20px;
  z-index: 2000;
  box-shadow: 0 4px 8px rgba(0,0,0,0.1);
}

  </style>

  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      margin: 0 !important;
      padding: 0 !important;
      overflow: hidden;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
    }
    
    html {
      margin: 0 !important;
      padding: 0 !important;
    }

    /* Fancy animations */
    @keyframes float {
      0%, 100% { transform: translateY(0px); }
      50% { transform: translateY(-10px); }
    }

    @keyframes pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.05); }
    }

    @keyframes glow {
      0%, 100% { box-shadow: 0 4px 15px rgba(0, 123, 255, 0.3); }
      50% { box-shadow: 0 4px 25px rgba(0, 123, 255, 0.6); }
    }

    @keyframes slideIn {
      from { transform: translateX(100px); opacity: 0; }
      to { transform: translateX(0); opacity: 1; }
    }

    @keyframes fadeInUp {
      from { transform: translateY(30px); opacity: 0; }
      to { transform: translateY(0); opacity: 1; }
    }

    #editor {
      padding: 20px;
      animation: fadeInUp 0.8s ease-out;
      position: relative;
    }

    #editor::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(45deg, rgba(255,255,255,0.1), rgba(255,255,255,0.05));
      border-radius: 15px;
      z-index: -1;
      backdrop-filter: blur(10px);
    }



    #editor iframe {
      width: 100%;
      height: calc(100vh - 60px);
      border: none;
    }

    #publishBtn {
      position: fixed;
      bottom: 20px;
      right: 20px;
      padding: 16px 24px;
      background: linear-gradient(135deg, #dc3545, #c82333);
      color: white;
      border: none;
      font-weight: 700;
      cursor: pointer;
      z-index: 9999;
      box-shadow: 0 10px 30px rgba(220, 53, 69, 0.4);
      transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 14px;
      width: 130px;
      height: 60px;
      justify-content: center;
      animation: slideIn 0.6s ease-out;
      backdrop-filter: blur(15px);
      border: 2px solid rgba(255, 255, 255, 0.3);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      position: relative;
      overflow: hidden;
      clip-path: polygon(20% 0%, 80% 0%, 100% 50%, 80% 100%, 20% 100%, 0% 50%);
      transform: rotate(0deg);
    }

    #publishBtn::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
      transition: left 0.6s;
      clip-path: polygon(20% 0%, 80% 0%, 100% 50%, 80% 100%, 20% 100%, 0% 50%);
    }

    #publishBtn:hover::before {
      left: 100%;
    }

    #publishBtn:hover {
      transform: translateY(-4px) scale(1.08) rotate(-3deg);
      box-shadow: 0 15px 40px rgba(220, 53, 69, 0.6);
      background: linear-gradient(135deg, #e74c3c, #c0392b);
    }

    #publishBtn:active {
      transform: translateY(-2px) scale(0.95) rotate(-7deg);
      box-shadow: 0 8px 25px rgba(220, 53, 69, 0.5);
    }

    #publishBtn:disabled {
      opacity: 0.7;
      cursor: not-allowed;
      transform: none;
    }

    .spinner {
      width: 16px;
      height: 16px;
      border: 2px solid rgba(255, 255, 255, 0.3);
      border-top: 2px solid white;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      display: none;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    .commit-status {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.9);
      color: white;
      padding: 20px 30px;
      border-radius: 12px;
      z-index: 3000;
      text-align: center;
      display: none;
      backdrop-filter: blur(10px);
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
    }

    .commit-status .spinner {
      display: inline-block;
      margin-bottom: 15px;
    }

    /* Enhanced status bar with types */
    .status-info {
      background: linear-gradient(135deg, rgba(0,123,255,0.9), rgba(0,86,179,0.8)) !important;
    }

    .status-success {
      background: linear-gradient(135deg, rgba(40,167,69,0.9), rgba(32,201,151,0.8)) !important;
    }

    .status-warning {
      background: linear-gradient(135deg, rgba(255,193,7,0.9), rgba(224,168,0,0.8)) !important;
      color: black !important;
    }

    .status-error {
      background: linear-gradient(135deg, rgba(220,53,69,0.9), rgba(200,35,51,0.8)) !important;
    }

    /* Quick actions panel */
    .quick-actions {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: linear-gradient(135deg, #ffffff, #f8f9fa);
      border-radius: 16px;
      padding: 25px;
      z-index: 2500;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.15);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.2);
      max-width: 350px;
      max-height: 70vh;
      text-align: center;
      display: none;
      overflow-y: auto;
    }

    .quick-actions h3 {
      margin: 0 0 20px 0;
      color: #2c3e50;
      font-size: 18px;
      font-weight: 600;
    }

    .action-item {
      display: flex;
      align-items: center;
      padding: 12px 16px;
      margin: 8px 0;
      background: white;
      border: 2px solid #e9ecef;
      border-radius: 10px;
      cursor: pointer;
      transition: all 0.3s ease;
      font-size: 14px;
      font-weight: 500;
    }

    .action-item:hover {
      border-color: #007bff;
      background: #f8f9ff;
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0, 123, 255, 0.15);
    }

    .action-item .icon {
      margin-right: 12px;
      font-size: 20px;
    }

    /* Progress bar for operations */
    .progress-bar {
      position: fixed;
      top: 0;
      left: 0;
      width: 0%;
      height: 3px;
      background: linear-gradient(90deg, #007bff, #28a745);
      z-index: 10000;
      transition: width 0.3s ease;
    }

    /* Floating action button */
    .fab {
      position: fixed;
      bottom: 80px;
      right: 20px;
      width: 56px;
      height: 56px;
      border-radius: 50%;
      background: linear-gradient(135deg, #6f42c1, #5a32a3);
      color: white;
      border: none;
      cursor: pointer;
      box-shadow: 0 4px 15px rgba(111, 66, 193, 0.3);
      transition: all 0.3s ease;
      z-index: 9999;
      font-size: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .fab:hover {
      transform: translateY(-2px) scale(1.1);
      box-shadow: 0 6px 20px rgba(111, 66, 193, 0.4);
    }

    /* Keyboard shortcuts indicator - commented out to use inline styles */
    /*
    .shortcuts-hint {
      position: fixed;
      top: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 8px 12px;
      border-radius: 6px;
      font-size: 11px;
      z-index: 9999;
      opacity: 0.7;
      transition: opacity 0.3s ease;
    }
    */

    .shortcuts-hint:hover {
      opacity: 1;
    }

    /* Dark mode styles */
    .dark-mode {
      background: #1a1a1a !important;
      color: #ffffff !important;
    }

    .dark-mode #editor {
      background: #2d2d2d !important;
    }

    .dark-mode .edit-overlay {
      background: linear-gradient(135deg, #2d2d2d, #1a1a1a) !important;
      color: #ffffff !important;
    }

    .dark-mode .edit-overlay input,
    .dark-mode .edit-overlay select,
    .dark-mode .edit-overlay textarea {
      background: #3d3d3d !important;
      color: #ffffff !important;
      border-color: #555 !important;
    }

    .dark-mode .edit-option {
      background: #3d3d3d !important;
      color: #ffffff !important;
      border-color: #555 !important;
    }

    .dark-mode .action-item {
      background: #3d3d3d !important;
      color: #ffffff !important;
      border-color: #555 !important;
    }

    .dark-mode .action-item:hover {
      background: #4d4d4d !important;
      border-color: #007bff !important;
    }

    /* Bulk styling button hover effects */
    #applyToSameBgColor:hover,
    #applyToSameTextColor:hover,
    #applyToSameTag:hover {
      background: #007bff !important;
      color: white !important;
      transform: translateY(-1px);
      box-shadow: 0 2px 8px rgba(0, 123, 255, 0.3);
    }

    .hover-highlight {
      outline: 2px dashed red;
    }

    .edit-backdrop {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0, 0, 0, 0.3);
      z-index: 1900;
    }

    .edit-overlay {
      position: fixed;
      min-width: 380px;
      max-width: 500px;
      max-height: 80vh;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: linear-gradient(135deg, #ffffff, #f8f9fa);
      border: none;
      border-radius: 20px;
      padding: 30px;
      z-index: 2100;
      box-shadow: 0 25px 80px rgba(0, 0, 0, 0.2);
      backdrop-filter: blur(20px);
      border: 1px solid rgba(255, 255, 255, 0.3);
      overflow-y: auto;
      overflow-x: hidden;
      animation: fadeInUp 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    }

    .edit-overlay h3 {
      margin: 0 0 20px 0;
      color: #2c3e50;
      font-size: 18px;
      font-weight: 600;
      text-align: center;
    }

    .edit-overlay label {
      display: block;
      margin-bottom: 8px;
      color: #495057;
      font-weight: 500;
      font-size: 14px;
    }

    .edit-overlay select {
      width: 100%;
      padding: 12px 16px;
      border: 2px solid #e9ecef;
      border-radius: 8px;
      background: white;
      font-size: 14px;
      margin-bottom: 15px;
      transition: border-color 0.3s ease;
      cursor: pointer;
    }

    .edit-overlay select:focus {
      outline: none;
      border-color: #007bff;
      box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.1);
    }

    .edit-overlay button {
      padding: 12px 24px;
      border: none;
      border-radius: 8px;
      font-weight: 600;
      font-size: 14px;
      cursor: pointer;
      transition: all 0.3s ease;
      margin-right: 10px;
      margin-bottom: 10px;
    }

    .edit-overlay button.primary {
      background: linear-gradient(135deg, #667eea, #764ba2);
      color: white;
      border-radius: 12px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      border: 2px solid rgba(255, 255, 255, 0.2);
      position: relative;
      overflow: hidden;
    }

    .edit-overlay button.primary::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
      transition: left 0.6s;
    }

    .edit-overlay button.primary:hover::before {
      left: 100%;
    }

    .edit-overlay button.primary:hover {
      transform: translateY(-3px) scale(1.05);
      box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
      background: linear-gradient(135deg, #7c8ff0, #8a5bb8);
    }

    .edit-overlay button.secondary {
      background: linear-gradient(135deg, #ff6b6b, #ee5a52);
      color: white;
      border-radius: 12px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      border: 2px solid rgba(255, 255, 255, 0.2);
      position: relative;
      overflow: hidden;
    }

    .edit-overlay button.secondary::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
      transition: left 0.6s;
    }

    .edit-overlay button.secondary:hover::before {
      left: 100%;
    }

    .edit-overlay button.secondary:hover {
      transform: translateY(-3px) scale(1.05);
      box-shadow: 0 8px 25px rgba(255, 107, 107, 0.4);
      background: linear-gradient(135deg, #ff8a8a, #ff6b6b);
    }

    /* Ensure edit overlay content is clickable */
    .edit-overlay * {
      pointer-events: auto;
    }

    .edit-overlay button {
      position: relative;
      z-index: 2200;
      pointer-events: auto;
    }

    /* Custom scrollbar for edit overlay */
    .edit-overlay::-webkit-scrollbar {
      width: 8px;
    }

    .edit-overlay::-webkit-scrollbar-track {
      background: #f1f1f1;
      border-radius: 4px;
    }

    .edit-overlay::-webkit-scrollbar-thumb {
      background: #c1c1c1;
      border-radius: 4px;
    }

    .edit-overlay::-webkit-scrollbar-thumb:hover {
      background: #a8a8a8;
    }

    .edit-overlay input[type="file"] {
      width: 100%;
      padding: 10px;
      border: 2px dashed #dee2e6;
      border-radius: 8px;
      background: #f8f9fa;
      margin-top: 10px;
      cursor: pointer;
    }

    .edit-overlay input[type="file"]:hover {
      border-color: #007bff;
      background: #e3f2fd;
    }

    .edit-overlay input[type="text"],
    .edit-overlay input[type="url"] {
      width: 100%;
      padding: 12px 16px;
      border: 2px solid #e9ecef;
      border-radius: 8px;
      font-size: 14px;
      margin-bottom: 15px;
      transition: border-color 0.3s ease;
    }

    .edit-overlay input[type="text"]:focus,
    .edit-overlay input[type="url"]:focus {
      outline: none;
      border-color: #007bff;
      box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.1);
    }

    .edit-overlay .form-group {
      margin-bottom: 15px;
    }

    .edit-overlay .form-group label {
      display: block;
      margin-bottom: 5px;
      font-weight: 600;
      color: #333;
    }

    .edit-overlay .form-group input[type="checkbox"] {
      margin-right: 8px;
      transform: scale(1.2);
    }

    .edit-overlay .button-group {
      display: flex;
      gap: 10px;
      margin-top: 20px;
      flex-wrap: wrap;
    }

    .edit-overlay button.danger {
      background: linear-gradient(135deg, #ff6b6b, #ee5a52);
      color: white;
      border: none;
      padding: 12px 20px;
      border-radius: 8px;
      cursor: pointer;
      font-weight: 600;
      transition: all 0.3s ease;
      box-shadow: 0 4px 15px rgba(255, 107, 107, 0.3);
    }

    .edit-overlay button.danger:hover {
      background: linear-gradient(135deg, #ff8a8a, #ff6b6b);
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(255, 107, 107, 0.4);
    }

    /* Page Selector Styles */
    #pageSelect {
      appearance: none;
      -webkit-appearance: none;
      -moz-appearance: none;
      background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='white'%3e%3cpath d='M7 10l5 5 5-5z'/%3e%3c/svg%3e");
      background-repeat: no-repeat;
      background-position: right 8px center;
      background-size: 20px;
      padding-right: 35px !important;
    }

    #pageSelect:focus {
      border-color: #007bff !important;
      box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.2) !important;
      background-color: rgba(255, 255, 255, 0.2) !important;
    }

    #pageSelect option {
      background-color: #2c3e50;
      color: white;
      padding: 8px 12px;
      font-size: 14px;
    }

    #pageSelect option:hover {
      background-color: #34495e;
    }

    #pageSelect option:checked {
      background-color: #007bff;
    }

    .edit-options-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 10px;
      margin-bottom: 20px;
    }

    .edit-option {
      padding: 20px;
      border: 2px solid #e9ecef;
      border-radius: 12px;
      background: linear-gradient(135deg, #ffffff, #f8f9fa);
      cursor: pointer;
      transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
      text-align: center;
      font-weight: 600;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
      position: relative;
      overflow: hidden;
    }

    .edit-option::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
      transition: left 0.5s;
    }

    .edit-option:hover::before {
      left: 100%;
    }

    .edit-option:hover {
      border-color: #007bff;
      background: linear-gradient(135deg, #f8f9ff, #e3f2fd);
      transform: translateY(-4px) scale(1.02);
      box-shadow: 0 8px 25px rgba(0, 123, 255, 0.2);
    }

    .edit-option.selected {
      border-color: #007bff;
      background: linear-gradient(135deg, #e3f2fd, #bbdefb);
      color: #007bff;
      transform: scale(1.05);
      box-shadow: 0 8px 25px rgba(0, 123, 255, 0.3);
    }

    /* Button hover effects */
    #helpBtn:hover, #loremBtn:hover, #undoBtn:hover {
      transform: translateY(-5px) scale(1.1);
      box-shadow: 0 15px 40px rgba(0, 0, 0, 0.4);
    }

    #helpBtn:hover {
      box-shadow: 0 15px 40px rgba(255, 107, 107, 0.6);
      background: linear-gradient(135deg, #ff8a8a, #ff6b6b);
      animation: pulse 2s infinite;
      transform: translateY(-5px) scale(1.1) rotate(8deg);
    }

    #loremBtn:hover {
      box-shadow: 0 15px 40px rgba(254, 202, 87, 0.6);
      background: linear-gradient(135deg, #ffd93d, #ff9ff3);
      animation: float 2s infinite;
      transform: translateY(-5px) scale(1.1) rotate(-6deg);
    }

    #undoBtn:hover {
      box-shadow: 0 15px 40px rgba(72, 219, 251, 0.6);
      background: linear-gradient(135deg, #6ee7ff, #48dbfb);
      animation: glow 2s infinite;
      transform: translateY(-5px) scale(1.1) rotate(5deg);
    }

    #helpBtn:active, #loremBtn:active, #undoBtn:active {
      transform: translateY(-3px) scale(0.95);
    }

    /* Shimmer effect for all buttons */
    #helpBtn::before, #loremBtn::before, #undoBtn::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
      transition: left 0.6s;
      clip-path: polygon(20% 0%, 80% 0%, 100% 50%, 80% 100%, 20% 100%, 0% 50%);
    }

    #helpBtn:hover::before, #loremBtn:hover::before, #undoBtn:hover::before {
      left: 100%;
    }

    /* Dormant button hover effect */
    button[style*="linear-gradient(135deg, #a55eea"]:hover {
      transform: translateY(-5px) scale(1.1) rotate(4deg);
      box-shadow: 0 15px 40px rgba(165, 94, 234, 0.6);
      background: linear-gradient(135deg, #b794f4, #a55eea) !important;
      animation: pulse 2s infinite;
    }

    button[style*="linear-gradient(135deg, #a55eea"]:active {
      transform: translateY(-3px) scale(0.95) rotate(-2deg);
    }

    .dormant {
      display: none !important;
    }

    .dormant-revealed {
      display: inline-block !important;
      outline: 2px dotted #e67e22 !important;
      background: #fffbe6 !important;
      color: #e67e22 !important;
      opacity: 0.8;
      cursor: pointer;
    }

    .editable-form-embed {
      width: 100% !important;
      height: 500px;
      display: block;
      border: none;
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    .iframe-wrapper {
      position: relative;
      display: inline-block;
      overflow: hidden;
    }
    
    .iframe-overlay {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: transparent;
      z-index: 1000;
      cursor: pointer;
    }
  </style>
</head>

<body>
  <div id="editor">
    <iframe id="pageFrame"></iframe>
  </div>
  
  <!-- Page Selector Dropdown -->
  <div id="pageSelector" style="position: fixed; bottom: 100px; left: 20px; z-index: 10000; background: linear-gradient(135deg, rgba(0,0,0,0.95), rgba(0,0,0,0.9)); padding: 15px 20px; border-radius: 12px; backdrop-filter: blur(15px); box-shadow: 0 8px 25px rgba(0,0,0,0.4); border: 1px solid rgba(255,255,255,0.2); min-width: 220px;">
    <label for="pageSelect" style="color: white; font-weight: 600; margin-bottom: 8px; display: block; font-size: 14px;">üìÑ Select Page:</label>
    <select id="pageSelect" style="width: 100%; padding: 10px 12px; border-radius: 8px; border: 2px solid rgba(255,255,255,0.3); background: rgba(255,255,255,0.15); color: white; font-size: 14px; cursor: pointer; font-weight: 500; transition: all 0.3s ease; outline: none;">
      <!-- Pages will be populated by JavaScript -->
    </select>
  </div>
  
  <button id="saveWorkBtn" style="position: fixed; bottom: 420px; right: 20px; padding: 16px 20px; background: linear-gradient(135deg, #28a745, #20c997); color: white; border: none; cursor: pointer; z-index: 9999; font-weight: 700; box-shadow: 0 10px 30px rgba(40, 167, 69, 0.4); transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275); width: 130px; height: 60px; backdrop-filter: blur(15px); border: 2px solid rgba(255, 255, 255, 0.3); animation: slideIn 0.6s ease-out 0.4s both; text-transform: uppercase; letter-spacing: 0.5px; overflow: hidden; clip-path: polygon(20% 0%, 80% 0%, 100% 50%, 80% 100%, 20% 100%, 0% 50%); transform: rotate(0deg);">üíæ Save Work</button>
  
  <button id="publishBtn" style="position: fixed; bottom: 20px; right: 20px; padding: 16px 20px; background: linear-gradient(135deg, #dc3545, #c82333); color: white; border: none; cursor: pointer; z-index: 9999; font-weight: 700; box-shadow: 0 10px 30px rgba(220, 53, 69, 0.4); transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275); width: 130px; height: 60px; backdrop-filter: blur(15px); border: 2px solid rgba(255, 255, 255, 0.3); animation: slideIn 0.6s ease-out 0.5s both; text-transform: uppercase; letter-spacing: 0.5px; overflow: hidden; clip-path: polygon(20% 0%, 80% 0%, 100% 50%, 80% 100%, 20% 100%, 0% 50%); transform: rotate(0deg);">üåê PUBLISH TO WEB</button>
  <div id="statusBar" style="position: fixed; top: 10px; right: 10px; background: linear-gradient(135deg, rgba(0,0,0,0.9), rgba(0,0,0,0.8)); color: white; padding: 15px 20px; border-radius: 12px; font-size: 13px; z-index: 9999; display: none; backdrop-filter: blur(15px); box-shadow: 0 8px 25px rgba(0,0,0,0.3); font-weight: 600; border: 1px solid rgba(255,255,255,0.1); animation: slideIn 0.4s ease-out;">Ready</div>
  <div id="commitStatus" class="commit-status">
    <div class="spinner"></div>
    <h3>Committing Changes...</h3>
    <p>Please wait 30-45 seconds to see changes on mainframe</p>
  </div>
  <button id="helpBtn" style="position: fixed; bottom: 340px; right: 20px; padding: 16px 20px; background: linear-gradient(135deg, #ff6b6b, #ee5a52); color: white; border: none; cursor: pointer; z-index: 9999; font-weight: 700; box-shadow: 0 10px 30px rgba(255, 107, 107, 0.4); transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275); width: 130px; height: 60px; backdrop-filter: blur(15px); border: 2px solid rgba(255, 255, 255, 0.3); animation: slideIn 0.6s ease-out 0.1s both; text-transform: uppercase; letter-spacing: 0.5px; overflow: hidden; clip-path: polygon(20% 0%, 80% 0%, 100% 50%, 80% 100%, 20% 100%, 0% 50%); transform: rotate(0deg);">‚ùì Help</button>
  <button id="loremBtn" style="position: fixed; bottom: 260px; right: 20px; padding: 16px 20px; background: linear-gradient(135deg, #feca57, #ff9ff3); color: white; border: none; cursor: pointer; z-index: 9999; font-weight: 700; box-shadow: 0 10px 30px rgba(254, 202, 87, 0.4); transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275); width: 130px; height: 60px; backdrop-filter: blur(15px); border: 2px solid rgba(255, 255, 255, 0.3); animation: slideIn 0.6s ease-out 0.2s both; text-transform: uppercase; letter-spacing: 0.5px; overflow: hidden; clip-path: polygon(20% 0%, 80% 0%, 100% 50%, 80% 100%, 20% 100%, 0% 50%); transform: rotate(0deg);">üìù Lorem</button>
  <button id="undoBtn" style="position: fixed; bottom: 180px; right: 20px; padding: 16px 20px; background: linear-gradient(135deg, #48dbfb, #0abde3); color: white; border: none; cursor: pointer; z-index: 9999; font-weight: 700; box-shadow: 0 10px 30px rgba(72, 219, 251, 0.4); transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275); width: 130px; height: 60px; backdrop-filter: blur(15px); border: 2px solid rgba(255, 255, 255, 0.3); animation: slideIn 0.6s ease-out 0.3s both; text-transform: uppercase; letter-spacing: 0.5px; overflow: hidden; clip-path: polygon(20% 0%, 80% 0%, 100% 50%, 80% 100%, 20% 100%, 0% 50%); transform: rotate(0deg);">‚Ü∂ Undo</button>
  
  <!-- New automation elements -->
  <div class="progress-bar"></div>
  <div class="shortcuts-hint" style="position: fixed; bottom: 20px; left: 20px; z-index: 10001; background: linear-gradient(135deg, rgba(0,0,0,0.95), rgba(0,0,0,0.9)); color: white; padding: 4px 15px; font-size: 10px; backdrop-filter: blur(15px); box-shadow: 0 4px 15px rgba(0,0,0,0.4); font-weight: 600; border: 1px solid rgba(255,255,255,0.2); opacity: 1; border-radius: 8px; height: 40px; display: flex; align-items: center;">
    Ctrl+S: Save | Ctrl+R: Reload | Ctrl+Z: Undo | Ctrl+Shift+A: Quick Actions
  </div>
  <div class="quick-actions" id="quickActions">
    <h3>Quick Actions</h3>
    <div id="actionsList"></div>
  </div>


  <script>
    const USERNAME = 'will292929';
    const REPO = 'test3';
    let FILE_PATH = 'index.html';
    const BRANCH = 'main';
    let TOKEN = localStorage.getItem('github_token') || prompt('Enter GitHub Token:');
    if (TOKEN) localStorage.setItem('github_token', TOKEN);
    
    // Validate token format
    if (TOKEN && !TOKEN.startsWith('ghp_') && !TOKEN.startsWith('github_pat_')) {
      alert('‚ö†Ô∏è Invalid token format. Please use a GitHub Personal Access Token.');
      TOKEN = prompt('Enter valid GitHub Token:');
      if (TOKEN) localStorage.setItem('github_token', TOKEN);
    }
    
    // Page selector functionality
    // ADD NEW PAGES HERE - just add a new line with the filename
    const AVAILABLE_PAGES = [
      'index.html',
      'about.html',
      'contact.html',
      'services.html',
      'portfolio.html',
      'blog.html',
      'pricing.html',
      'faq.html'
    ];
    
    // Initialize page selector dropdown
    function initializePageSelector() {
      const pageSelect = document.getElementById('pageSelect');
      const pageSelector = document.getElementById('pageSelector');
      
      // Ensure the page selector is visible
      pageSelector.style.display = 'block';
      pageSelector.style.visibility = 'visible';
      pageSelector.style.opacity = '1';
      
      // Clear existing options
      pageSelect.innerHTML = '';
      
      // Add options for each available page
      AVAILABLE_PAGES.forEach(page => {
        const option = document.createElement('option');
        option.value = page;
        option.textContent = page;
        if (page === FILE_PATH) {
          option.selected = true;
        }
        pageSelect.appendChild(option);
      });
      
      // Ensure the select element is properly styled and visible
      pageSelect.style.display = 'block';
      pageSelect.style.visibility = 'visible';
      pageSelect.style.opacity = '1';
      pageSelect.style.zIndex = '10001';
      
      // Add change event listener
      pageSelect.addEventListener('change', function() {
        const selectedPage = this.value;
        if (selectedPage !== FILE_PATH) {
          switchPage(selectedPage);
        }
      });
      
      // Add click event to ensure dropdown opens
      pageSelect.addEventListener('click', function(e) {
        e.stopPropagation();
        this.focus();
      });
      
      console.log('Page selector initialized with', AVAILABLE_PAGES.length, 'pages');
    }
    
    // Function to switch pages
    async function switchPage(newPage) {
      try {
        showStatus(`üîÑ Switching to ${newPage}...`, 2000, 'info');
        
        // Save current state if needed
        const doc = frame.contentDocument || frame.contentWindow.document;
        if (doc && doc.documentElement) {
          // You could save the current page state here if needed
        }
        
        // Update FILE_PATH and load new page
        FILE_PATH = newPage;
        await loadHTML();
        
        // Reset history for new page
        initializeHistory();
        
        showStatus(`‚úÖ Switched to ${newPage}`, 2000, 'success');
        
      } catch (error) {
        console.error('Failed to switch page:', error);
        showStatus(`‚ùå Failed to load ${newPage}`, 3000, 'error');
      }
    }
    
    // History for undo functionality
    let history = [];
    let historyIndex = -1;
    const MAX_HISTORY = 20;
    let isUndoing = false; // Flag to prevent conflicts during undo
    
    // Initialize history when frame loads
    function initializeHistory() {
      console.log('üîÑ Attempting to initialize history...');
      const doc = frame.contentDocument || frame.contentWindow.document;
      console.log('Document available:', !!doc);
      console.log('Document element available:', !!(doc && doc.documentElement));
      
      if (doc && doc.documentElement) {
        const html = doc.documentElement.outerHTML;
        history = [html];
        historyIndex = 0;
        const undoBtn = document.getElementById('undoBtn');
        undoBtn.disabled = true;
        console.log('üöÄ History initialized. Index:', historyIndex, 'History length:', history.length, 'HTML length:', html.length);
      } else {
        console.log('‚ùå Could not initialize history - no document available');
        console.log('Frame src:', frame.src);
        console.log('Frame srcdoc:', frame.srcdoc ? 'has content' : 'no content');
      }
    }
    
    // Status bar functionality
    function showStatus(message, duration = 3000, type = 'info') {
      const statusBar = document.getElementById('statusBar');
      statusBar.textContent = message;
      statusBar.style.display = 'block';
      
      // Add type-based styling
      statusBar.className = `status-${type}`;
      
      if (duration > 0) {
        setTimeout(() => {
          statusBar.style.display = 'none';
        }, duration);
      }
    }

    // Auto-save functionality
    let autoSaveInterval;
    let lastSavedState = '';
    
    function startAutoSave() {
      autoSaveInterval = setInterval(() => {
        const doc = frame.contentDocument || frame.contentWindow.document;
        const currentState = doc.documentElement.outerHTML;
        
        if (currentState !== lastSavedState) {
          lastSavedState = currentState;
          showStatus('üíæ Auto-saving...', 1000, 'info');
        }
      }, 30000); // Auto-save every 30 seconds
    }

    function stopAutoSave() {
      if (autoSaveInterval) {
        clearInterval(autoSaveInterval);
      }
    }

    // Smart element detection
    function detectElementType(el) {
      const tag = el.tagName.toLowerCase();
      const text = el.innerText?.trim();
      const hasText = !!text;
      const hasImage = el.querySelector('img') || tag === 'img';
      const hasLink = el.querySelector('a') || tag === 'a';
      
      return {
        type: hasImage ? 'image' : hasLink ? 'link' : hasText ? 'text' : 'container',
        tag: tag,
        hasText: hasText,
        hasImage: hasImage,
        hasLink: hasLink
      };
    }

    // Smart suggestions
    function getSmartSuggestions(el) {
      const detection = detectElementType(el);
      const suggestions = [];
      
      switch (detection.type) {
        case 'image':
          suggestions.push('browse', 'style', 'copy', 'delete');
          break;
        case 'link':
          suggestions.push('url', 'text', 'style', 'copy', 'delete');
          break;
        case 'text':
          suggestions.push('text', 'style', 'copy', 'delete');
          break;
        default:
          suggestions.push('text', 'style', 'googleform', 'youtube', 'copy', 'delete');
      }
      
      return suggestions;
    }


    const frame = document.getElementById('pageFrame');
    let spaceHeld = false, spaceJustUsed = false, sha = '';


    // Listen globally for spacebar mode
    window.addEventListener('keydown', e => {
      if (e.code === 'Space' && !spaceHeld) {
        spaceHeld = true;
        spaceJustUsed = false;
      }
      
      // Ctrl+S to commit
      if (e.ctrlKey && e.key === 's') {
        e.preventDefault();
        commitBtn.click();
        showStatus('üíæ Saved!', 2000, 'success');
      }
      
      // Ctrl+R to reload
      if (e.ctrlKey && e.key === 'r') {
        e.preventDefault();
        loadHTML();
        showStatus('üîÑ Reloaded!', 2000, 'info');
      }
      
      // Ctrl+Z to undo
      if (e.ctrlKey && e.key === 'z') {
        e.preventDefault();
        document.getElementById('undoBtn').click();
        showStatus('‚Ü∂ Undone!', 2000, 'info');
      }

      // Ctrl+Shift+A for quick actions
      if (e.ctrlKey && e.shiftKey && e.key === 'A') {
        e.preventDefault();
        showQuickActions();
      }

      // Escape to close modals
      if (e.key === 'Escape') {
        document.querySelectorAll('.edit-overlay, .quick-actions').forEach(el => el.remove());
        document.querySelectorAll('.edit-backdrop').forEach(el => el.remove());
      }
    });
    window.addEventListener('keyup', e => {
      if (e.code === 'Space') {
        spaceHeld = false;
        spaceJustUsed = false;
      }
    });

    // Quick actions functions
    function showQuickActions() {
      // Remove any existing backdrops
      document.querySelectorAll('.quick-actions-backdrop').forEach(el => el.remove());
      
      // Create backdrop
      const backdrop = document.createElement('div');
      backdrop.className = 'quick-actions-backdrop';
      backdrop.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: rgba(0, 0, 0, 0.3);
        z-index: 2400;
        cursor: pointer;
      `;
      
      // Close on backdrop click
      backdrop.onclick = () => {
        document.getElementById('quickActions').style.display = 'none';
        backdrop.remove();
      };
      
      const actionsList = document.getElementById('actionsList');
      actionsList.innerHTML = '';
      
      const actions = [
        { icon: 'üíæ', text: 'Save Work (Local)', action: () => saveWorkBtn.click() },
        { icon: 'üåê', text: 'PUBLISH TO WEB', action: () => {
          if (confirm('‚ö†Ô∏è This will publish your changes to the live website. Are you sure you want to commit to the main files?')) {
            publishBtn.click();
          }
        }},
        { icon: 'üîÑ', text: 'Reload Page', action: () => loadHTML() },
        { icon: '‚Ü∂', text: 'Undo Last Change', action: () => document.getElementById('undoBtn').click() },
        { icon: 'üëÅÔ∏è', text: 'Toggle Dormant Elements', action: () => dormantBtn.click() },
        { icon: 'üìã', text: 'Copy Page URL', action: () => copyPageUrl() },
        { icon: 'üé®', text: 'Toggle Dark Mode', action: () => toggleDarkMode() },
        { icon: 'üìä', text: 'Page Statistics', action: () => showPageStats() },
        { icon: 'üìÇ', text: 'Load Saved Work', action: () => loadSavedWork() },
        { icon: 'üîÑ', text: 'Reload & Reset', action: () => {
          if (confirm('This will reload the page and reset all changes. Continue?')) {
            loadHTML();
            history = [];
            historyIndex = -1;
            document.getElementById('undoBtn').disabled = true;
            showStatus('üîÑ Page reloaded and history reset!', 3000, 'info');
          }
        }}
      ];
      
      actions.forEach(action => {
        const item = document.createElement('div');
        item.className = 'action-item';
        item.innerHTML = `
          <span class="icon">${action.icon}</span>
          <span>${action.text}</span>
        `;
        item.onclick = () => {
          action.action();
          // Don't close immediately - let user click outside to close
        };
        actionsList.appendChild(item);
      });
      
      // Prevent clicks inside the popup from closing it
      document.getElementById('quickActions').onclick = (e) => {
        e.stopPropagation();
      };
      
      document.getElementById('quickActions').style.display = 'block';
      document.body.appendChild(backdrop);
    }

    function copyPageUrl() {
      const url = `https://${USERNAME}.github.io/${REPO}/${FILE_PATH}`;
      
      // Try modern clipboard API first
      if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(url).then(() => {
          showStatus('üìã URL copied to clipboard!', 2000, 'success');
        }).catch((error) => {
          console.log('Clipboard API failed:', error);
          // Fallback to old method
          fallbackCopyTextToClipboard(url);
        });
      } else {
        // Fallback for older browsers
        fallbackCopyTextToClipboard(url);
      }
    }
    
    function fallbackCopyTextToClipboard(text) {
      const textArea = document.createElement('textarea');
      textArea.value = text;
      textArea.style.position = 'fixed';
      textArea.style.left = '-999999px';
      textArea.style.top = '-999999px';
      document.body.appendChild(textArea);
      textArea.focus();
      textArea.select();
      
      try {
        const successful = document.execCommand('copy');
        if (successful) {
          showStatus('üìã URL copied to clipboard!', 2000, 'success');
        } else {
          showStatus('‚ùå Failed to copy URL', 2000, 'error');
        }
      } catch (err) {
        showStatus('‚ùå Failed to copy URL', 2000, 'error');
      }
      
      document.body.removeChild(textArea);
    }
    
    function loadSavedWork() {
      const savedWork = [];
      
      // Find all saved work for current file
      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key && key.startsWith('temp_work_') && key.includes(FILE_PATH)) {
          try {
            const data = JSON.parse(localStorage.getItem(key));
            savedWork.push({
              key: key,
              ...data
            });
          } catch (e) {
            console.error('Error parsing saved work:', e);
          }
        }
      }
      
      if (savedWork.length === 0) {
        showStatus('üìÇ No saved work found for this page', 3000, 'info');
        return;
      }
      
      // Sort by timestamp (newest first)
      savedWork.sort((a, b) => b.timestamp - a.timestamp);
      
      // Show selection dialog
      const overlay = document.createElement('div');
      overlay.className = 'edit-overlay';
      overlay.style.zIndex = '10002';
      const backdrop = document.createElement('div');
      backdrop.className = 'edit-backdrop';
      backdrop.style.zIndex = '10001';
      
      overlay.innerHTML = `
        <h3>üìÇ Load Saved Work</h3>
        <div style="max-height: 300px; overflow-y: auto;">
          ${savedWork.map((work, index) => `
            <div style="padding: 10px; margin: 5px 0; border: 1px solid #ddd; border-radius: 8px; cursor: pointer;" onclick="loadSpecificWork('${work.key}')">
              <strong>${work.description}</strong><br>
              <small>Saved: ${new Date(work.timestamp).toLocaleString()}</small>
            </div>
          `).join('')}
        </div>
        <div class="button-group">
          <button onclick="this.closest('.edit-overlay').remove(); this.closest('.edit-backdrop').remove();" class="secondary">Cancel</button>
        </div>
      `;
      
      document.body.append(backdrop, overlay);
      
      backdrop.onclick = () => {
        overlay.remove();
        backdrop.remove();
      };
    }
    
    function loadSpecificWork(key) {
      try {
        const data = JSON.parse(localStorage.getItem(key));
        if (data && data.html) {
          frame.srcdoc = data.html;
          frame.onload = () => {
            const doc = frame.contentDocument || frame.contentWindow.document;
            attachAllHandlers(doc);
            showStatus('üìÇ Loaded saved work!', 3000, 'success');
          };
          
          // Close the dialog
          document.querySelectorAll('.edit-overlay, .edit-backdrop').forEach(el => el.remove());
        }
      } catch (error) {
        console.error('Error loading saved work:', error);
        showStatus('‚ùå Failed to load saved work', 3000, 'error');
      }
    }

    function toggleDarkMode() {
      const body = document.body;
      body.classList.toggle('dark-mode');
      const isDark = body.classList.contains('dark-mode');
      showStatus(`üåô ${isDark ? 'Dark' : 'Light'} mode ${isDark ? 'enabled' : 'disabled'}!`, 2000, 'info');
    }

    function showPageStats() {
      const doc = frame.contentDocument || frame.contentWindow.document;
      const images = doc.querySelectorAll('img').length;
      const links = doc.querySelectorAll('a').length;
      const textElements = doc.querySelectorAll('p, h1, h2, h3, h4, h5, h6, span').length;
      const forms = doc.querySelectorAll('form, iframe').length;
      
      alert(`üìä Page Statistics:
      
üñºÔ∏è Images: ${images}
üîó Links: ${links}
üìù Text Elements: ${textElements}
üìã Forms/Embeds: ${forms}
üìÑ Total Elements: ${images + links + textElements + forms}`);
    }

    function cleanUpPage() {
      const doc = frame.contentDocument || frame.contentWindow.document;
      const dormantElements = doc.querySelectorAll('.dormant');
      
      if (dormantElements.length > 0) {
        if (confirm(`üßπ Clean up ${dormantElements.length} dormant elements?`)) {
          dormantElements.forEach(el => el.remove());
          showStatus(`üßπ Cleaned up ${dormantElements.length} elements!`, 3000, 'success');
          setTimeout(() => attachAllHandlers(doc), 100);
        }
      } else {
        showStatus('‚ú® Page is already clean!', 2000, 'info');
      }
    }

    // Bulk styling functions
    function setupBulkStylingButtons(overlay, currentEl, doc) {
      const applyToSameBgColor = overlay.querySelector('#applyToSameBgColor');
      const applyToSameTextColor = overlay.querySelector('#applyToSameTextColor');
      const applyToSameTag = overlay.querySelector('#applyToSameTag');
      
      applyToSameBgColor.onclick = () => {
        const currentBgColor = window.getComputedStyle(currentEl).backgroundColor;
        const similarElements = findElementsWithSameBackground(doc, currentBgColor);
        showBulkStylingConfirmation(similarElements, 'background color', () => {
          applyBulkStyling(similarElements, 'background');
        });
      };
      
      applyToSameTextColor.onclick = () => {
        const currentTextColor = window.getComputedStyle(currentEl).color;
        const similarElements = findElementsWithSameTextColor(doc, currentTextColor);
        showBulkStylingConfirmation(similarElements, 'text color', () => {
          applyBulkStyling(similarElements, 'text');
        });
      };
      
      applyToSameTag.onclick = () => {
        const currentTag = currentEl.tagName.toLowerCase();
        const similarElements = findElementsWithSameTag(doc, currentTag);
        showBulkStylingConfirmation(similarElements, 'tag type', () => {
          applyBulkStyling(similarElements, 'tag');
        });
      };
    }

    function findElementsWithSameBackground(doc, targetColor) {
      const elements = doc.querySelectorAll('*');
      const similarElements = [];
      
      elements.forEach(el => {
        const bgColor = window.getComputedStyle(el).backgroundColor;
        if (bgColor === targetColor && el !== doc.body && el !== doc.documentElement) {
          similarElements.push(el);
        }
      });
      
      return similarElements;
    }

    function findElementsWithSameTextColor(doc, targetColor) {
      const elements = doc.querySelectorAll('*');
      const similarElements = [];
      
      elements.forEach(el => {
        const textColor = window.getComputedStyle(el).color;
        if (textColor === targetColor && el !== doc.body && el !== doc.documentElement) {
          similarElements.push(el);
        }
      });
      
      return similarElements;
    }

    function findElementsWithSameTag(doc, targetTag) {
      return Array.from(doc.querySelectorAll(targetTag));
    }

    function showBulkStylingConfirmation(elements, type, onConfirm) {
      if (elements.length === 0) {
        showStatus(`‚ùå No elements found with the same ${type}`, 3000, 'warning');
        return;
      }
      
      const count = elements.length;
      const message = `üé® Apply styling to ${count} element${count > 1 ? 's' : ''} with the same ${type}?`;
      
      if (confirm(message)) {
        onConfirm();
        showStatus(`‚úÖ Applied styling to ${count} element${count > 1 ? 's' : ''}!`, 3000, 'success');
      }
    }

    function applyBulkStyling(elements, type) {
      const overlay = document.querySelector('.edit-overlay');
      const bgColorInput = overlay.querySelector('#bgColorInput');
      const textColorInput = overlay.querySelector('#textColorInput');
      const fontSizeInput = overlay.querySelector('#fontSizeInput');
      
      elements.forEach(el => {
        if (bgColorInput.value && (type === 'background' || type === 'tag')) {
          el.style.backgroundColor = bgColorInput.value;
        }
        if (textColorInput.value && (type === 'text' || type === 'tag')) {
          el.style.color = textColorInput.value;
        }
        if (fontSizeInput.value && type === 'tag') {
          el.style.fontSize = fontSizeInput.value;
        }
      });
      
      // Reattach handlers after styling
      setTimeout(() => {
        attachAllHandlers(frame.contentDocument || frame.contentWindow.document);
        saveToHistory();
      }, 100);
    }

    function showProgress(progress) {
      const progressBar = document.querySelector('.progress-bar');
      progressBar.style.width = `${progress}%`;
      
      if (progress >= 100) {
        setTimeout(() => {
          progressBar.style.width = '0%';
        }, 1000);
      }
    }



    // Help button functionality
    document.getElementById('helpBtn').onclick = () => {
      alert(`üéØ Visual GitHub Pages Editor Help

üìù How to use:
‚Ä¢ Click any element to edit it
‚Ä¢ Hold SPACEBAR + click to follow links
‚Ä¢ Use Ctrl+S to commit changes
‚Ä¢ Use Ctrl+R to reload the page
‚Ä¢ Use Ctrl+Z to undo changes
‚Ä¢ Use Ctrl+Shift+A for quick actions
‚Ä¢ Use Escape to close modals

üîß Edit options:
‚Ä¢ URL: Change links and image sources
‚Ä¢ Text: Edit text content
‚Ä¢ Browse & Upload: Upload new images
‚Ä¢ Styling: Change colors and fonts
‚Ä¢ Embed Google Form: Add form embeds
‚Ä¢ Embed YouTube Video: Add video embeds
‚Ä¢ Copy Element: Duplicate any element
‚Ä¢ Delete Element: Remove elements

üöÄ Enhanced Features:
‚Ä¢ Auto-save every 30 seconds
‚Ä¢ Smart element detection
‚Ä¢ Progress indicators
‚Ä¢ Enhanced status messages
‚Ä¢ Dark mode support
‚Ä¢ Page statistics
‚Ä¢ Quick cleanup tools
‚Ä¢ Keyboard shortcuts

üëÅÔ∏è Dormant elements:
‚Ä¢ Click "Show Dormant" to see hidden elements
‚Ä¢ Hidden elements are marked with orange outline
‚Ä¢ Click "Restore" to bring them back

üíæ Committing:
‚Ä¢ Changes are saved to your GitHub repository
‚Ä¢ Images are uploaded to /images/ folder
‚Ä¢ Dormant elements are hidden in the final page

üé¨ Supported embeds:
‚Ä¢ Google Forms (any form URL)
‚Ä¢ YouTube videos (any YouTube URL)`);
    };

    // Lorem Ipsum button functionality
    document.getElementById('loremBtn').onclick = () => {
      // Remove any existing popups
      document.querySelectorAll('.edit-backdrop, .edit-overlay').forEach(x => x.remove());

      const overlayBox = document.createElement('div');
      overlayBox.className = 'edit-overlay';
      const backdrop = document.createElement('div');
      backdrop.className = 'edit-backdrop';

      overlayBox.innerHTML = `
        <h3>üìù Lorem Ipsum Content</h3>
        <div style="max-height: 400px; overflow-y: auto; padding: 20px; background: rgba(255,255,255,0.95); border-radius: 8px; margin: 15px 0;">
          <p><strong>Lorem ipsum dolor sit amet</strong>, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.</p>
          
          <p>Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.</p>
          
          <p>Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo.</p>
          
          <p>Nemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit, sed quia consequuntur magni dolores eos qui ratione voluptatem sequi nesciunt.</p>
          
          <p>Neque porro quisquam est, qui dolorem ipsum quia dolor sit amet, consectetur, adipisci velit, sed quia non numquam eius modi tempora incidunt ut labore et dolore magnam aliquam quaerat voluptatem.</p>
          
          <p>Ut enim ad minima veniam, quis nostrum exercitationem ullam corporis suscipit laboriosam, nisi ut aliquid ex ea commodi consequatur? Quis autem vel eum iure reprehenderit qui in ea voluptate velit esse quam nihil molestiae consequatur, vel illum qui dolorem eum fugiat quo voluptas nulla pariatur?</p>
          
          <p>At vero eos et accusamus et iusto odio dignissimos ducimus qui blanditiis praesentium voluptatum deleniti atque corrupti quos dolores et quas molestias excepturi sint occaecati cupiditate non provident, similique sunt in culpa qui officia deserunt mollitia animi, id est laborum et dolorum fuga.</p>
          
          <p>Et harum quidem rerum facilis est et expedita distinctio. Nam libero tempore, cum soluta nobis est eligendi optio cumque nihil impedit quo minus id quod maxime placeat facere possimus, omnis voluptas assumenda est, omnis dolor repellendus.</p>
          
          <p>Temporibus autem quibusdam et aut officiis debitis aut rerum necessitatibus saepe eveniet ut et voluptates repudiandae sint et molestiae non recusandae. Itaque earum rerum hic tenetur a sapiente delectus, ut aut reiciendis voluptatibus maiores alias consequatur aut perferendis doloribus asperiores repellat.</p>
          
          <p>For more information, visit <a href="#" style="color: #007bff; text-decoration: underline;">our website</a> or contact us at <a href="mailto:info@example.com" style="color: #007bff; text-decoration: underline;">info@example.com</a>.</p>
          
          <p>You can also check out our <a href="#" style="color: #007bff; text-decoration: underline;">services page</a> and <a href="#" style="color: #007bff; text-decoration: underline;">about us</a> for additional details.</p>
        </div>
        <div class="button-group">
          <button id="closeLorem" class="primary">Close</button>
        </div>
      `;

      document.body.append(backdrop, overlayBox);

      backdrop.onclick = () => {
        overlayBox.remove();
        backdrop.remove();
      };

      document.getElementById('closeLorem').onclick = () => {
        overlayBox.remove();
        backdrop.remove();
      };
    };









    // Undo functionality
    function saveToHistory() {
      const doc = frame.contentDocument || frame.contentWindow.document;
      if (!doc || !doc.documentElement) {
        console.log('‚ùå No document available for history save');
        return;
      }
      
      const html = doc.documentElement.outerHTML;
      console.log('üíæ Saving to history. Current index:', historyIndex, 'History length:', history.length);
      
      // Remove current state and everything after it
      history = history.slice(0, historyIndex + 1);
      
      // Add new state
      history.push(html);
      historyIndex++;
      
      // Limit history size
      if (history.length > MAX_HISTORY) {
        history.shift();
        historyIndex--;
      }
      
      // Update undo button state
      const undoBtn = document.getElementById('undoBtn');
      undoBtn.disabled = historyIndex <= 0;
      
      console.log('‚úÖ History saved. New index:', historyIndex, 'History length:', history.length, 'Button disabled:', undoBtn.disabled);
      
      // Add fancy visual feedback
      undoBtn.style.transform = 'scale(1.1)';
      undoBtn.style.boxShadow = '0 8px 25px rgba(108, 117, 125, 0.4)';
      setTimeout(() => {
        undoBtn.style.transform = '';
        undoBtn.style.boxShadow = '';
      }, 300);
    }

    // Ensure undo button is properly connected
    const undoBtn = document.getElementById('undoBtn');
    if (undoBtn) {
      console.log('üîß Setting up undo button...');
      
      undoBtn.onclick = () => {
        console.log('üîÑ Undo button clicked!');
        console.log('Current state:', {
          historyIndex,
          historyLength: history.length,
          isUndoing,
          frameExists: !!frame,
          frameSrc: frame ? frame.src : 'no frame',
          buttonDisabled: undoBtn.disabled
        });
        
        if (isUndoing) {
          showStatus('‚è≥ Undo in progress...', 2000, 'warning');
          return;
        }
        
        console.log('üîÑ Undo clicked! History index:', historyIndex, 'History length:', history.length);
        
        if (historyIndex > 0) {
          isUndoing = true;
          historyIndex--;
          console.log('üìã Restoring to history index:', historyIndex);
          
          try {
            // Store the HTML we're about to restore
            const htmlToRestore = history[historyIndex];
            if (!htmlToRestore) {
              throw new Error('No HTML content in history at index ' + historyIndex);
            }
            console.log('üìÑ HTML length to restore:', htmlToRestore.length);
            
            // Get current scroll position before restoring
            const currentDoc = frame.contentDocument || frame.contentWindow.document;
            const currentScrollTop = currentDoc ? currentDoc.documentElement.scrollTop || currentDoc.body.scrollTop : 0;
            const currentScrollLeft = currentDoc ? currentDoc.documentElement.scrollLeft || currentDoc.body.scrollLeft : 0;
            
            console.log('üìç Preserving scroll position:', { top: currentScrollTop, left: currentScrollLeft });
            
            // Show loading state with fade effect
            showStatus('üîÑ Restoring previous state...', 0, 'info');
            
            // Add smooth transition effect
            frame.style.opacity = '0.7';
            frame.style.transition = 'opacity 0.3s ease';
            
            // Apply to main frame
            frame.srcdoc = htmlToRestore;
            
            // Wait for the main frame to load
            frame.onload = () => {
              const doc = frame.contentDocument || frame.contentWindow.document;
              if (doc) {
                // Restore scroll position
                doc.documentElement.scrollTop = currentScrollTop;
                doc.documentElement.scrollLeft = currentScrollLeft;
                doc.body.scrollTop = currentScrollTop;
                doc.body.scrollLeft = currentScrollLeft;
                
                // Smooth fade-in effect
                frame.style.opacity = '1';
                
                // Reattach handlers
                attachAllHandlers(doc);
                showDormantElements(dormantVisible);
                
                // Update button state
                undoBtn.disabled = historyIndex <= 0;
                
                console.log('‚úÖ Undo completed successfully with scroll restored');
                showStatus('‚Ü∂ Undone!', 2000, 'info');
                isUndoing = false;
              }
            };
          } catch (error) {
            console.error('‚ùå Error during undo:', error);
            showStatus('‚ùå Undo failed: ' + error.message, 3000, 'error');
            isUndoing = false;
          }
        } else {
          console.log('‚ùå Nothing to undo - history index is 0');
          showStatus('‚ùå Nothing to undo', 2000, 'warning');
        }
      };
      
      console.log('‚úÖ Undo button setup complete');
    } else {
      console.error('‚ùå Undo button not found!');
    }
        



    loadHTML();



    function insertEditableEmbed(container, embedUrl, width = "100%", height = "500px") {
      const doc = container.ownerDocument || document;

      console.log('Creating embed:', { embedUrl, width, height, container: container.tagName });

      // Clear the container completely if it's empty or only has whitespace
      if (!container.innerHTML.trim()) {
        container.innerHTML = '';
      } else {
        // Remove any existing iframes in the container
        const existingElements = container.querySelectorAll('iframe');
        console.log(`Removing ${existingElements.length} existing iframes from container`);
        Array.from(existingElements).forEach(el => el.remove());
      }

      // Create a wrapper div to hold the iframe and edit button
      const wrapper = doc.createElement('div');
      wrapper.style.position = 'relative';
      wrapper.style.display = 'inline-block';
      wrapper.style.width = width;
      wrapper.style.height = height;
      wrapper.style.maxWidth = '100%';

      // Create a simple, clean iframe
      const iframe = doc.createElement('iframe');
      iframe.src = embedUrl;
      iframe.style.width = '100%';
      iframe.style.height = '100%';
      iframe.style.border = "none";
      iframe.style.display = "block";
      iframe.style.margin = "0";
      iframe.style.boxSizing = "border-box";
      
      // Create a small edit button that appears in the top-right corner
      const editButton = doc.createElement('button');
      editButton.innerHTML = '‚úèÔ∏è';
      editButton.style.position = 'absolute';
      editButton.style.top = '5px';
      editButton.style.right = '5px';
      editButton.style.zIndex = '1000';
      editButton.style.background = '#007bff';
      editButton.style.color = 'white';
      editButton.style.border = 'none';
      editButton.style.borderRadius = '3px';
      editButton.style.padding = '3px 6px';
      editButton.style.fontSize = '12px';
      editButton.style.cursor = 'pointer';
      editButton.style.opacity = '0';
      editButton.style.transition = 'opacity 0.2s ease';
      
      // Show button on hover
      wrapper.onmouseenter = () => {
        editButton.style.opacity = '1';
      };
      
      wrapper.onmouseleave = () => {
        editButton.style.opacity = '0';
      };
      
      // Add click handler to the edit button
      editButton.onclick = (e) => {
        e.preventDefault();
        e.stopPropagation();
        
        // Show edit options
        doc.querySelectorAll('.edit-backdrop, .edit-overlay').forEach(x => x.remove());

        const overlayBox = doc.createElement('div');
        overlayBox.className = 'edit-overlay';
        const backdrop = doc.createElement('div');
        backdrop.className = 'edit-backdrop';

        overlayBox.innerHTML = `
          <label>Edit Embed:</label>
          <select id="editChoice">
            <option value="">Cancel</option>
            <option value="remove">Remove Embed</option>
          </select>
          <button id="editOk">OK</button>
        `;

        doc.body.append(backdrop, overlayBox);

        backdrop.onclick = () => {
          overlayBox.remove();
          backdrop.remove();
        };

        doc.getElementById('editOk').onclick = () => {
          const choice = doc.getElementById('editChoice').value;
          overlayBox.remove();
          backdrop.remove();

          if (choice === 'remove') {
            wrapper.remove();
            setTimeout(() => attachAllHandlers(doc), 0);
          }
        };
      };

      wrapper.appendChild(iframe);
      wrapper.appendChild(editButton);
      container.appendChild(wrapper);
    }
    function upgradeAllIframes(doc) {
      console.log('=== Starting iframe upgrade process ===');
      
      // First, clean any existing iframes that might have old editor attributes
      const existingIframes = doc.querySelectorAll('iframe');
      existingIframes.forEach(iframe => {
        // Remove any old editor attributes
        iframe.removeAttribute('data-embed-id');
        iframe.removeAttribute('data-editor-attached');
        iframe.classList.remove('editable-form-embed', 'editable-embed');
        
        // Clean up any old styles
        iframe.style.outline = '';
        iframe.style.transition = '';
        iframe.style.zIndex = '';
        iframe.style.pointerEvents = '';
      });
      
      // Find all iframes that need to be made editable
      let iframes = doc.querySelectorAll('iframe:not([data-editor-attached])');
      console.log(`Found ${iframes.length} iframes to make editable`);
      
      // Also check for any iframes that might be Google Forms
      const allIframes = doc.querySelectorAll('iframe');
      console.log(`Total iframes found: ${allIframes.length}`);
      allIframes.forEach((iframe, i) => {
        console.log(`Iframe ${i + 1}:`, {
          src: iframe.src,
          width: iframe.style.width || iframe.getAttribute('width'),
          height: iframe.style.height || iframe.getAttribute('height'),
          hasEditor: iframe.hasAttribute('data-editor-attached'),
          isGoogleForm: iframe.src && iframe.src.includes('docs.google.com')
        });
      });
      
      // If no iframes were found with the normal selector, try a more comprehensive approach
      if (iframes.length === 0 && allIframes.length > 0) {
        console.log('‚ö†Ô∏è No iframes found with normal selector, trying comprehensive approach...');
        iframes = Array.from(allIframes).filter(iframe => {
          // Check if iframe is not already wrapped in an editor
          const parent = iframe.parentElement;
          const hasEditButton = parent && parent.querySelector('button[style*="position: absolute"]');
          return !hasEditButton;
        });
        console.log(`Found ${iframes.length} iframes with comprehensive approach`);
      }
      
      iframes.forEach((iframe, index) => {
        const src = iframe.src || '';
        const parent = iframe.parentElement;
        
        // Get dimensions, preferring inline styles over attributes
        let width = iframe.style.width || iframe.getAttribute('width') || "100%";
        let height = iframe.style.height || iframe.getAttribute('height') || "500px";
        
        // Clean up dimension values
        if (width === 'medium' || width === '') width = "100%";
        if (height === 'medium' || height === '') height = "500px";
        
        console.log(`Making iframe ${index + 1} editable:`, { src, width, height });
        
        // Special handling for Google Forms
        const isGoogleForm = src.includes('docs.google.com');
        if (isGoogleForm) {
          console.log('üîç Google Form detected:', src);
        }
        
        // Create a wrapper for this iframe
        const wrapper = doc.createElement('div');
        wrapper.style.position = 'relative';
        wrapper.style.display = 'inline-block';
        wrapper.style.width = width;
        wrapper.style.height = height;
        wrapper.style.maxWidth = '100%';
        
        // Apply proper styling to iframe
        iframe.style.width = '100%';
        iframe.style.height = '100%';
        iframe.style.border = "none";
        iframe.style.display = "block";
        iframe.style.margin = "0";
        iframe.style.boxSizing = "border-box";
        
        // Create edit button
        const editButton = doc.createElement('button');
        editButton.innerHTML = '‚úèÔ∏è';
        editButton.style.position = 'absolute';
        editButton.style.top = '5px';
        editButton.style.right = '5px';
        editButton.style.zIndex = '1000';
        editButton.style.background = '#007bff';
        editButton.style.color = 'white';
        editButton.style.border = 'none';
        editButton.style.borderRadius = '3px';
        editButton.style.padding = '3px 6px';
        editButton.style.fontSize = '12px';
        editButton.style.cursor = 'pointer';
        editButton.style.opacity = '0';
        editButton.style.transition = 'opacity 0.2s ease';
        
        // Show button on hover
        wrapper.onmouseenter = () => {
          editButton.style.opacity = '1';
        };
        
        wrapper.onmouseleave = () => {
          editButton.style.opacity = '0';
        };
        
        // Add click handler to the edit button
        editButton.onclick = (e) => {
          e.preventDefault();
          e.stopPropagation();
          
          doc.querySelectorAll('.edit-backdrop, .edit-overlay').forEach(x => x.remove());

          const overlayBox = doc.createElement('div');
          overlayBox.className = 'edit-overlay';
          const backdrop = doc.createElement('div');
          backdrop.className = 'edit-backdrop';

          overlayBox.innerHTML = `
            <h3>Edit Iframe</h3>
            <div class="form-group">
              <label for="iframeSrc">Source URL:</label>
              <input type="text" id="iframeSrc" value="${iframe.src || ''}" placeholder="Enter iframe URL">
            </div>
            <div class="form-group">
              <label for="iframeWidth">Width:</label>
              <input type="text" id="iframeWidth" value="${width}" placeholder="e.g., 100%, 500px">
            </div>
            <div class="form-group">
              <label for="iframeHeight">Height:</label>
              <input type="text" id="iframeHeight" value="${height}" placeholder="e.g., 500px, 100vh">
            </div>
            <div class="form-group">
              <label for="iframeTitle">Title (for accessibility):</label>
              <input type="text" id="iframeTitle" value="${iframe.title || ''}" placeholder="Enter iframe title">
            </div>
            <div class="form-group">
              <label>
                <input type="checkbox" id="makeDormant" ${iframe.classList.contains('dormant') ? 'checked' : ''}>
                Make Dormant (hide from normal view)
              </label>
            </div>
            <div class="button-group">
              <button id="editOk" class="primary">Apply Changes</button>
              <button id="editCancel" class="secondary">Cancel</button>
              <button id="removeIframe" class="danger">Remove Iframe</button>
            </div>
          `;

          doc.body.append(backdrop, overlayBox);

          backdrop.onclick = () => {
            overlayBox.remove();
            backdrop.remove();
          };

          // Apply Changes button
          doc.getElementById('editOk').onclick = () => {
            const newSrc = doc.getElementById('iframeSrc').value;
            const newWidth = doc.getElementById('iframeWidth').value;
            const newHeight = doc.getElementById('iframeHeight').value;
            const newTitle = doc.getElementById('iframeTitle').value;
            const makeDormant = doc.getElementById('makeDormant').checked;
            
            // Update iframe properties
            if (newSrc) iframe.src = newSrc;
            if (newTitle) iframe.title = newTitle;
            
            // Update wrapper dimensions
            if (newWidth) wrapper.style.width = newWidth;
            if (newHeight) wrapper.style.height = newHeight;
            
            // Handle dormant state
            if (makeDormant) {
              iframe.classList.add('dormant');
              wrapper.classList.add('dormant');
            } else {
              iframe.classList.remove('dormant');
              wrapper.classList.remove('dormant');
            }
            
            overlayBox.remove();
            backdrop.remove();
            showStatus('‚úÖ Iframe updated successfully', 2000, 'success');
          };
          
          // Cancel button
          doc.getElementById('editCancel').onclick = () => {
            overlayBox.remove();
            backdrop.remove();
          };
          
          // Remove iframe button
          doc.getElementById('removeIframe').onclick = () => {
            wrapper.remove();
            overlayBox.remove();
            backdrop.remove();
            setTimeout(() => attachAllHandlers(doc), 0);
            showStatus('üóëÔ∏è Iframe removed', 2000, 'info');
          };
        };
        
        // Move iframe into wrapper
        parent.insertBefore(wrapper, iframe);
        wrapper.appendChild(iframe);
        wrapper.appendChild(editButton);
      });
      
      console.log('=== Iframe upgrade complete ===');
    }
    
    // Special function to make Google Forms editable
    function makeGoogleFormsEditable(doc) {
      const googleForms = doc.querySelectorAll('iframe[src*="docs.google.com"]');
      console.log(`Found ${googleForms.length} Google Forms to make editable`);
      
      googleForms.forEach((iframe, index) => {
        console.log(`Making Google Form ${index + 1} editable:`, iframe.src);
        
        // Check if already has editor
        const parent = iframe.parentElement;
        const hasEditButton = parent && parent.querySelector('button[style*="position: absolute"]');
        
        if (!hasEditButton) {
          // Create wrapper and edit button for this Google Form
          const wrapper = doc.createElement('div');
          wrapper.style.position = 'relative';
          wrapper.style.display = 'inline-block';
          wrapper.style.width = iframe.style.width || iframe.getAttribute('width') || '100%';
          wrapper.style.height = iframe.style.height || iframe.getAttribute('height') || '500px';
          wrapper.style.maxWidth = '100%';
          
          // Style the iframe
          iframe.style.width = '100%';
          iframe.style.height = '100%';
          iframe.style.border = 'none';
          iframe.style.display = 'block';
          iframe.style.margin = '0';
          iframe.style.boxSizing = 'border-box';
          
          // Create edit button
          const editButton = doc.createElement('button');
          editButton.innerHTML = '‚úèÔ∏è';
          editButton.style.position = 'absolute';
          editButton.style.top = '5px';
          editButton.style.right = '5px';
          editButton.style.zIndex = '1000';
          editButton.style.background = '#007bff';
          editButton.style.color = 'white';
          editButton.style.border = 'none';
          editButton.style.borderRadius = '3px';
          editButton.style.padding = '3px 6px';
          editButton.style.fontSize = '12px';
          editButton.style.cursor = 'pointer';
          editButton.style.opacity = '0';
          editButton.style.transition = 'opacity 0.2s ease';
          
          // Show button on hover
          wrapper.onmouseenter = () => {
            editButton.style.opacity = '1';
          };
          
          wrapper.onmouseleave = () => {
            editButton.style.opacity = '0';
          };
          
          // Add the same click handler as the main iframe editor
          editButton.onclick = (e) => {
            e.preventDefault();
            e.stopPropagation();
            
            doc.querySelectorAll('.edit-backdrop, .edit-overlay').forEach(x => x.remove());

            const overlayBox = doc.createElement('div');
            overlayBox.className = 'edit-overlay';
            const backdrop = doc.createElement('div');
            backdrop.className = 'edit-backdrop';

            overlayBox.innerHTML = `
              <h3>Edit Google Form</h3>
              <div class="form-group">
                <label for="iframeSrc">Form URL:</label>
                <input type="text" id="iframeSrc" value="${iframe.src || ''}" placeholder="Enter Google Form URL">
              </div>
              <div class="form-group">
                <label for="iframeWidth">Width:</label>
                <input type="text" id="iframeWidth" value="${wrapper.style.width}" placeholder="e.g., 100%, 500px">
              </div>
              <div class="form-group">
                <label for="iframeHeight">Height:</label>
                <input type="text" id="iframeHeight" value="${wrapper.style.height}" placeholder="e.g., 500px, 100vh">
              </div>
              <div class="form-group">
                <label for="iframeTitle">Title (for accessibility):</label>
                <input type="text" id="iframeTitle" value="${iframe.title || ''}" placeholder="Enter form title">
              </div>
              <div class="form-group">
                <label>
                  <input type="checkbox" id="makeDormant" ${iframe.classList.contains('dormant') ? 'checked' : ''}>
                  Make Dormant (hide from normal view)
                </label>
              </div>
              <div class="button-group">
                <button id="editOk" class="primary">Apply Changes</button>
                <button id="editCancel" class="secondary">Cancel</button>
                <button id="removeIframe" class="danger">Remove Form</button>
              </div>
            `;

            doc.body.append(backdrop, overlayBox);

            backdrop.onclick = () => {
              overlayBox.remove();
              backdrop.remove();
            };

            // Apply Changes button
            doc.getElementById('editOk').onclick = () => {
              const newSrc = doc.getElementById('iframeSrc').value;
              const newWidth = doc.getElementById('iframeWidth').value;
              const newHeight = doc.getElementById('iframeHeight').value;
              const newTitle = doc.getElementById('iframeTitle').value;
              const makeDormant = doc.getElementById('makeDormant').checked;
              
              // Update iframe properties
              if (newSrc) iframe.src = newSrc;
              if (newTitle) iframe.title = newTitle;
              
              // Update wrapper dimensions
              if (newWidth) wrapper.style.width = newWidth;
              if (newHeight) wrapper.style.height = newHeight;
              
              // Handle dormant state
              if (makeDormant) {
                iframe.classList.add('dormant');
                wrapper.classList.add('dormant');
              } else {
                iframe.classList.remove('dormant');
                wrapper.classList.remove('dormant');
              }
              
              overlayBox.remove();
              backdrop.remove();
              showStatus('‚úÖ Google Form updated successfully', 2000, 'success');
            };
            
            // Cancel button
            doc.getElementById('editCancel').onclick = () => {
              overlayBox.remove();
              backdrop.remove();
            };
            
            // Remove iframe button
            doc.getElementById('removeIframe').onclick = () => {
              wrapper.remove();
              overlayBox.remove();
              backdrop.remove();
              setTimeout(() => attachAllHandlers(doc), 0);
              showStatus('üóëÔ∏è Google Form removed', 2000, 'info');
            };
          };
          
          // Move iframe into wrapper
          const parent = iframe.parentElement;
          parent.insertBefore(wrapper, iframe);
          wrapper.appendChild(iframe);
          wrapper.appendChild(editButton);
          
          console.log(`‚úÖ Google Form ${index + 1} made editable`);
        }
      });
    }



  
    function attachAllHandlers(doc) {
      // ‚úÖ First, upgrade any raw iframes to be editable
      upgradeAllIframes(doc);
      
      // ‚úÖ Special handling for Google Forms
      makeGoogleFormsEditable(doc);

      // ‚úÖ Remove old handlers
      doc.querySelectorAll('[data-editor-attached]').forEach(el => {
        el.removeAttribute('data-editor-attached');
        el.onclick = null;
      });

      const elements = doc.querySelectorAll('a,img,button,iframe,span,p,div,h1,h2,h3,h4,h5,h6,strong,b,em');

      elements.forEach(el => {
        const tag = el.tagName.toLowerCase();
        const text = el.innerText?.trim();
        const hasText = !!text;

        // ‚ùå Skip dormant unless revealed
        if (el.classList.contains('dormant') && !dormantVisible) return;






        // ‚ùå Skip large containers (with multiple children or nested blocks)
        const childTags = Array.from(el.children).map(c => c.tagName?.toLowerCase());
        const isAtomic = childTags.length <= 1 && !childTags.some(t => ['p', 'div', 'section', 'h1', 'h2', 'h3', 'h4'].includes(t));
        if (!['img', 'a', 'iframe', 'button'].includes(tag) && !isAtomic) return;

        el.setAttribute('data-editor-attached', 'yes');

        el.onclick = async e => {
          const iframeSpaceHeld = doc._iframeSpaceHeld || false;
          const fullSpaceHeld = spaceHeld || iframeSpaceHeld;

          // Smart element detection and feedback
          const detection = detectElementType(el);
          showStatus(`üéØ Editing ${detection.type}: ${el.innerText?.trim().substring(0, 20) || el.tagName}`, 2000, 'info');

          // üîó Identify editable attribute
          let attr = null;
          if (tag === 'a') attr = 'href';
          else if (['img', 'iframe'].includes(tag)) attr = 'src';
          else if (tag === 'button') {
            if (el.hasAttribute('href')) attr = 'href';
            else if (el.hasAttribute('data-link')) attr = 'data-link';
            else if (el.hasAttribute('onclick')) attr = 'onclick';
          }
          else if (tag === 'div' && el.hasAttribute('src')) {
            const innerA = el.querySelector('a');
            if (innerA) {
              attr = 'href';
              el = innerA; // now edits will target the <a>
            }
          }


          // ‚å®Ô∏è Spacebar link follow behavior
          if (fullSpaceHeld && !spaceJustUsed) {
            spaceJustUsed = true;
            if (attr && el.getAttribute(attr)) {
              window.open(el.getAttribute(attr), '_blank');
            }
            return;
          }
          if (fullSpaceHeld) return;

          e.preventDefault();
          document.querySelectorAll('.edit-backdrop, .edit-overlay').forEach(x => x.remove());

          // üß† Build overlay
          const overlay = document.createElement('div');
          overlay.className = 'edit-overlay';
          const backdrop = document.createElement('div');
          backdrop.className = 'edit-backdrop';

          overlay.innerHTML = `
        <h3>Edit Element</h3>
        <div class="edit-options-grid">
          <div class="edit-option" data-value="url">
            <div style="font-size: 24px; margin-bottom: 8px;">üîó</div>
            <div>URL/Link</div>
          </div>
          <div class="edit-option" data-value="text">
            <div style="font-size: 24px; margin-bottom: 8px;">üìù</div>
            <div>Text Content</div>
          </div>
          <div class="edit-option" data-value="browse">
            <div style="font-size: 24px; margin-bottom: 8px;">üñºÔ∏è</div>
            <div>Upload Image</div>
          </div>
          <div class="edit-option" data-value="style">
            <div style="font-size: 24px; margin-bottom: 8px;">üé®</div>
            <div>Styling</div>
          </div>
          <div class="edit-option" data-value="googleform">
            <div style="font-size: 24px; margin-bottom: 8px;">üìã</div>
            <div>Google Form</div>
          </div>
          <div class="edit-option" data-value="youtube">
            <div style="font-size: 24px; margin-bottom: 8px;">üé¨</div>
            <div>YouTube Video</div>
          </div>
          <div class="edit-option" data-value="copy">
            <div style="font-size: 24px; margin-bottom: 8px;">üìã</div>
            <div>Copy Element</div>
          </div>
          <div class="edit-option" data-value="dormant">
            <div style="font-size: 24px; margin-bottom: 8px;">üëÅÔ∏è</div>
            <div>Hide Element</div>
          </div>
          ${(el.classList.contains('dormant') || el.classList.contains('dormant-revealed')) ? 
            '<div class="edit-option" data-value="restore"><div style="font-size: 24px; margin-bottom: 8px;">üîÑ</div><div>Restore</div></div>' : ''}
          <div class="edit-option" data-value="delete">
            <div style="font-size: 24px; margin-bottom: 8px;">üóëÔ∏è</div>
            <div>Delete</div>
          </div>
        </div>
        
        <div id="editDetails" style="display: none;">
          <div id="urlEdit" style="display: none;">
            <label>URL/Link:</label>
            <input type="url" id="urlInput" placeholder="Enter URL...">
          </div>
          <div id="textEdit" style="display: none;">
            <label>Text Content:</label>
            <textarea id="textInput" rows="3" placeholder="Enter text..." style="width: 100%; padding: 12px 16px; border: 2px solid #e9ecef; border-radius: 8px; font-size: 14px; margin-bottom: 15px; resize: vertical;"></textarea>
          </div>
          <div id="styleEdit" style="display: none;">
            <label>Background Color:</label>
            <input type="color" id="bgColorInput" style="width: 100%; height: 40px; border: 2px solid #e9ecef; border-radius: 8px; margin-bottom: 15px;">
            <label>Text Color:</label>
            <input type="color" id="textColorInput" style="width: 100%; height: 40px; border: 2px solid #e9ecef; border-radius: 8px; margin-bottom: 15px;">
            <label>Font Size:</label>
            <select id="fontSizeInput" style="width: 100%; padding: 12px 16px; border: 2px solid #e9ecef; border-radius: 8px; font-size: 14px; margin-bottom: 15px;">
              <option value="">Keep current</option>
              <option value="12px">Small (12px)</option>
              <option value="14px">Normal (14px)</option>
              <option value="16px">Medium (16px)</option>
              <option value="18px">Large (18px)</option>
              <option value="24px">Extra Large (24px)</option>
              <option value="32px">Huge (32px)</option>
            </select>
            
            <div style="margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid #007bff;">
              <label style="font-weight: 600; color: #007bff; margin-bottom: 10px; display: block;">üé® Apply to Similar Elements:</label>
              <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                <button type="button" id="applyToSameBgColor" style="padding: 8px 12px; background: #e3f2fd; border: 1px solid #007bff; border-radius: 6px; color: #007bff; cursor: pointer; font-size: 12px; transition: all 0.3s ease;">Same Background</button>
                <button type="button" id="applyToSameTextColor" style="padding: 8px 12px; background: #e3f2fd; border: 1px solid #007bff; border-radius: 6px; color: #007bff; cursor: pointer; font-size: 12px; transition: all 0.3s ease;">Same Text Color</button>
                <button type="button" id="applyToSameTag" style="padding: 8px 12px; background: #e3f2fd; border: 1px solid #007bff; border-radius: 6px; color: #007bff; cursor: pointer; font-size: 12px; transition: all 0.3s ease;">Same Tag Type</button>
              </div>
              <div style="margin-top: 10px; font-size: 11px; color: #666;">
                üí° Select one of these options to apply your changes to all similar elements
              </div>
            </div>
          </div>
          <div id="imageEdit" style="display: none;">
            <label>Upload New Image:</label>
            <input type="file" id="imgInput" accept="image/*" style="width: 100%; padding: 10px; border: 2px dashed #dee2e6; border-radius: 8px; background: #f8f9fa; margin-top: 10px; cursor: pointer;">
            <div style="margin-top: 15px; padding: 15px; background: #f8f9fa; border-radius: 8px;">
              <label>Or enter image URL:</label>
              <input type="url" id="imageUrlInput" placeholder="https://example.com/image.jpg" style="width: 100%; padding: 12px 16px; border: 2px solid #e9ecef; border-radius: 8px; font-size: 14px; margin-top: 8px;">
            </div>
          </div>
          <div id="googleFormEdit" style="display: none;">
            <label>Google Form URL:</label>
            <input type="url" id="googleFormUrlInput" placeholder="https://docs.google.com/forms/d/e/..." style="width: 100%; padding: 12px 16px; border: 2px solid #e9ecef; border-radius: 8px; font-size: 14px; margin-bottom: 15px;">
            <div style="padding: 10px; background: #e3f2fd; border-radius: 8px; font-size: 12px; color: #1976d2;">
              üí° Tip: Paste your Google Form URL and it will be automatically embedded
            </div>
          </div>
          <div id="youtubeEdit" style="display: none;">
            <label>YouTube Video URL:</label>
            <input type="url" id="youtubeUrlInput" placeholder="https://www.youtube.com/watch?v=..." style="width: 100%; padding: 12px 16px; border: 2px solid #e9ecef; border-radius: 8px; font-size: 14px; margin-bottom: 15px;">
            <div style="padding: 10px; background: #fff3e0; border-radius: 8px; font-size: 12px; color: #f57c00;">
              üí° Tip: Paste any YouTube video URL and it will be automatically embedded
            </div>
          </div>
        </div>
        
        <div style="text-align: center; margin-top: 20px; position: sticky; bottom: 0; background: linear-gradient(135deg, #ffffff, #f8f9fa); padding: 15px 0; border-top: 1px solid #e9ecef; z-index: 2200;">
          <button id="editOk" class="primary" style="position: relative; z-index: 2200;">Apply Changes</button>
          <button id="editCancel" class="secondary" style="position: relative; z-index: 2200;">Cancel</button>
        </div>
      `;

          document.body.append(backdrop, overlay);
          
          // Handle option selection
          const options = overlay.querySelectorAll('.edit-option');
          const editDetails = overlay.querySelector('#editDetails');
          
          options.forEach(option => {
            option.addEventListener('click', () => {
              // Remove previous selection
              options.forEach(opt => opt.classList.remove('selected'));
              option.classList.add('selected');
              
              // Add visual feedback
              option.style.transform = 'scale(0.95)';
              setTimeout(() => {
                option.style.transform = '';
              }, 150);
              
              const value = option.getAttribute('data-value');
              showEditDetails(value);
            });
          });
          
          function showEditDetails(choice) {
            // Hide all detail sections
            overlay.querySelectorAll('#editDetails > div').forEach(div => div.style.display = 'none');
            editDetails.style.display = 'none';
            
            if (choice === 'url') {
              editDetails.style.display = 'block';
              overlay.querySelector('#urlEdit').style.display = 'block';
              const urlInput = overlay.querySelector('#urlInput');
              urlInput.value = el.getAttribute(attr || 'src') || '';
            } else if (choice === 'text') {
              editDetails.style.display = 'block';
              overlay.querySelector('#textEdit').style.display = 'block';
              const textInput = overlay.querySelector('#textInput');
              textInput.value = el.innerText.trim() || '';
            } else if (choice === 'style') {
              editDetails.style.display = 'block';
              overlay.querySelector('#styleEdit').style.display = 'block';
              const bgColorInput = overlay.querySelector('#bgColorInput');
              const textColorInput = overlay.querySelector('#textColorInput');
              const fontSizeInput = overlay.querySelector('#fontSizeInput');
              
              // Set current values
              const computedStyle = window.getComputedStyle(el);
              bgColorInput.value = rgbToHex(computedStyle.backgroundColor);
              textColorInput.value = rgbToHex(computedStyle.color);
              fontSizeInput.value = computedStyle.fontSize;
              
              // Add event listeners for bulk styling
              setupBulkStylingButtons(overlay, el, doc);
            } else if (choice === 'browse') {
              editDetails.style.display = 'block';
              overlay.querySelector('#imageEdit').style.display = 'block';
              const imageUrlInput = overlay.querySelector('#imageUrlInput');
              imageUrlInput.value = el.getAttribute(attr || 'src') || '';
            } else if (choice === 'googleform') {
              editDetails.style.display = 'block';
              overlay.querySelector('#googleFormEdit').style.display = 'block';
            } else if (choice === 'youtube') {
              editDetails.style.display = 'block';
              overlay.querySelector('#youtubeEdit').style.display = 'block';
            }
          }
          
          function rgbToHex(rgb) {
            if (!rgb || rgb === 'rgba(0, 0, 0, 0)' || rgb === 'transparent') return '#000000';
            const match = rgb.match(/^rgba?\((\d+),\s*(\d+),\s*(\d+)/);
            if (!match) return '#000000';
            const r = parseInt(match[1]);
            const g = parseInt(match[2]);
            const b = parseInt(match[3]);
            return '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
          }
          
          backdrop.onclick = () => { overlay.remove(); backdrop.remove(); };
          overlay.querySelector('#editCancel').onclick = () => { overlay.remove(); backdrop.remove(); };

          document.getElementById('editOk').onclick = async () => {
            const selectedOption = overlay.querySelector('.edit-option.selected');
            if (!selectedOption) return;
            
            const choice = selectedOption.getAttribute('data-value');
            overlay.remove(); backdrop.remove();
            if (!choice) return;

            if (choice === 'url') {
              const urlInput = overlay.querySelector('#urlInput');
              const newVal = urlInput.value.trim();
              if (newVal) {
                if (tag === 'button') {
                  // Prefer data-link if present
                  if (el.hasAttribute('data-link')) {
                    el.setAttribute('data-link', newVal);
                  } else {
                    el.setAttribute('onclick', `location.href='${newVal}'`);
                  }
                } else {
                  el.setAttribute(attr || 'src', newVal);
                  if (tag === 'iframe') el.src = newVal;
                }
                saveToHistory();
              }
            }


            else if (choice === 'text') {
              const textInput = overlay.querySelector('#textInput');
              const newText = textInput.value.trim();
              
              if (newText !== null) {
                // Clear existing content and add new text
                el.innerHTML = '';
                el.appendChild(document.createTextNode(newText));
                saveToHistory();
              }
            }



            else if (choice === 'style') {
              const bgColorInput = overlay.querySelector('#bgColorInput');
              const textColorInput = overlay.querySelector('#textColorInput');
              const fontSizeInput = overlay.querySelector('#fontSizeInput');
              
              if (bgColorInput.value) {
                el.style.backgroundColor = bgColorInput.value;
              }
              if (textColorInput.value) {
                el.style.color = textColorInput.value;
              }
              if (fontSizeInput.value) {
                el.style.fontSize = fontSizeInput.value;
              }
              saveToHistory();
            }
            
            else if (choice === 'browse') {
              const imgInput = overlay.querySelector('#imgInput');
              const imageUrlInput = overlay.querySelector('#imageUrlInput');
              
              // Handle file upload
              if (imgInput.files && imgInput.files[0]) {
                const file = imgInput.files[0];
                const reader = new FileReader();
                reader.onloadend = async () => {
                  try {
                    const b64 = reader.result.split(',')[1];

                    // === 1. Delete previous image if needed ===
                    const prevFile = el.getAttribute('data-image-file');
                    if (prevFile) {
                      try {
                        const res = await fetch(`https://api.github.com/repos/${USERNAME}/${REPO}/contents/${prevFile}`, {
                          method: 'GET',
                          headers: { 'Authorization': `Bearer ${TOKEN}` }
                        });
                        if (res.ok) {
                          const data = await res.json();
                          const deleteRes = await fetch(`https://api.github.com/repos/${USERNAME}/${REPO}/contents/${prevFile}`, {
                            method: 'DELETE',
                            headers: {
                              'Authorization': `Bearer ${TOKEN}`,
                              'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                              message: `Delete old image ${prevFile}`,
                              sha: data.sha,
                              branch: BRANCH
                            })
                          });
                          if (!deleteRes.ok) throw new Error("Could not delete previous image");
                        }
                      } catch (err) {
                        console.warn("No previous image to delete or failed to delete:", err.message);
                      }
                    }

                    // === 2. Upload new image ===
                    const safeName = `img_${Date.now()}_${file.name.replace(/[^a-z0-9.\-_]/gi, '_').toLowerCase()}`;
                    const githubPath = `images/${safeName}`;

                    await apiCommit(githubPath, b64, `Upload image ${safeName}`);

                    // === 3. Apply new image and track it ===
                    el.setAttribute(attr || 'src', githubPath);
                    el.setAttribute('data-image-file', githubPath);

                    if (tag === 'img') el.src = githubPath;
                    setTimeout(() => attachAllHandlers(doc), 50);

                    alert(`‚úÖ Uploaded and linked: ${githubPath}`);
                  } catch (err) {
                    alert('‚ùå Upload failed: ' + err.message);
                  }
                };
                reader.onerror = () => alert("‚ùå Could not read file.");
                reader.readAsDataURL(file);
              }
              
              // Handle URL input
              else if (imageUrlInput.value.trim()) {
                const imageUrl = imageUrlInput.value.trim();
                el.setAttribute(attr || 'src', imageUrl);
                if (tag === 'img') el.src = imageUrl;
                setTimeout(() => {
                  attachAllHandlers(doc);
                  saveToHistory();
                }, 50);
              }
            }



            else if (choice === 'dormant') {
              el.classList.add('dormant');
              el.classList.remove('dormant-revealed');
              if (attr) {
                el.setAttribute(`data-original-${attr}`, el.getAttribute(attr) || '');
                el.removeAttribute(attr);
              }
              if (el.innerText) {
                el.setAttribute('data-original-text', el.innerText);
                el.innerText = '';
              }
              saveToHistory();
            }

            else if (choice === 'restore') {
              el.classList.remove('dormant');
              el.classList.remove('dormant-revealed');
              const originalText = el.getAttribute('data-original-text');
              if (originalText) {
                el.innerText = originalText;
                el.removeAttribute('data-original-text');
              }

              const attrs = ['src', 'href', 'data-link', 'onclick'];
              attrs.forEach(attr => {
                const original = el.getAttribute(`data-original-${attr}`);
                if (original) {
                  el.setAttribute(attr, original);
                  el.removeAttribute(`data-original-${attr}`);
                }
              });
              saveToHistory();
            }

            else if (choice === 'googleform') {
              const googleFormUrlInput = overlay.querySelector('#googleFormUrlInput');
              const formUrl = googleFormUrlInput.value.trim();
              if (!formUrl) return;

              const embedUrl = formUrl.includes("embedded=true")
                ? formUrl
                : formUrl.replace('/viewform', '/viewform?embedded=true');

              // Create a new div container for the embed instead of using the existing element
              const newContainer = doc.createElement('div');
              newContainer.style.margin = '20px 0';
              newContainer.style.textAlign = 'center';
              
              // Insert the new container after the clicked element
              el.parentNode.insertBefore(newContainer, el.nextSibling);
              
              insertEditableEmbed(newContainer, embedUrl);
              
              // Add a visual indicator that the embed was added
              setTimeout(() => {
                newContainer.style.outline = '2px solid #28a745';
                newContainer.style.outlineOffset = '5px';
                setTimeout(() => {
                  newContainer.style.outline = '';
                  newContainer.style.outlineOffset = '';
                }, 2000);
              }, 100);
              saveToHistory();
            }

            else if (choice === 'removeform') {
              if (el.tagName === 'IFRAME') {
                el.remove();
                return;
              }

              const iframe = el.querySelector('iframe');
              if (iframe) {
                iframe.remove();
              } else {
                alert("‚ö†Ô∏è No embedded form found in this element.");
              }
            }


            else if (choice === 'youtube') {
              const youtubeUrlInput = overlay.querySelector('#youtubeUrlInput');
              const videoUrl = youtubeUrlInput.value.trim();
              if (!videoUrl) return;
              
              // Extract video ID from various YouTube URL formats
              let videoId = '';
              const patterns = [
                /(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/)([^&\n?#]+)/,
                /youtube\.com\/v\/([^&\n?#]+)/
              ];
              
              for (const pattern of patterns) {
                const match = videoUrl.match(pattern);
                if (match) {
                  videoId = match[1];
                  break;
                }
              }
              
              if (!videoId) {
                alert('‚ùå Invalid YouTube URL. Please use a valid YouTube video link.');
                return;
              }
              
              const embedUrl = `https://www.youtube.com/embed/${videoId}`;
              
              // Create a new div container for the embed
              const newContainer = doc.createElement('div');
              newContainer.style.margin = '20px 0';
              newContainer.style.textAlign = 'center';
              
              // Insert the new container after the clicked element
              el.parentNode.insertBefore(newContainer, el.nextSibling);
              
              insertEditableEmbed(newContainer, embedUrl);
              
              // Add visual indicator
              setTimeout(() => {
                newContainer.style.outline = '2px solid #ff0000';
                newContainer.style.outlineOffset = '5px';
                setTimeout(() => {
                  newContainer.style.outline = '';
                  newContainer.style.outlineOffset = '';
                }, 2000);
              }, 100);
              saveToHistory();
            }
            
            else if (choice === 'copy') {
              const clonedElement = el.cloneNode(true);
              // Remove editor-specific attributes from clone
              clonedElement.removeAttribute('data-editor-attached');
              clonedElement.onclick = null;
              
              // Insert after the original element
              el.parentNode.insertBefore(clonedElement, el.nextSibling);
              
              // Add visual indicator
              setTimeout(() => {
                clonedElement.style.outline = '2px solid #28a745';
                clonedElement.style.outlineOffset = '5px';
                setTimeout(() => {
                  clonedElement.style.outline = '';
                  clonedElement.style.outlineOffset = '';
                }, 2000);
              }, 100);
              saveToHistory();
            }
            
            else if (choice === 'delete') {
              if (confirm('Are you sure you want to delete this element?')) {
                el.remove();
                saveToHistory();
              }
            }

            setTimeout(() => {
              attachAllHandlers(doc);
              showStatus('‚úÖ Changes applied!', 2000, 'success');
            }, 100);
          };
        };
      });
    }






    function showDormantElements(show) {
      const doc = frame.contentDocument || frame.contentWindow.document;
      const dormantEls = doc.querySelectorAll('.dormant, .dormant-revealed');

      dormantEls.forEach(el => {
        if (show) {
          // Convert .dormant ‚ûú .dormant-revealed
          el.classList.remove('dormant');
          el.classList.add('dormant-revealed');

          // Restore text
          const text = el.getAttribute('data-original-text');
          if (text && el.innerText.trim() === '') {
            el.innerText = text;
          }

          // Restore src, href, etc
          const attrs = ['src', 'href', 'data-link', 'onclick'];
          attrs.forEach(attr => {
            const original = el.getAttribute(`data-original-${attr}`);
            if (original && !el.getAttribute(attr)) {
              el.setAttribute(attr, original);
            }
          });
        } else {
          // Convert .dormant-revealed ‚ûú .dormant
          el.classList.add('dormant');
          el.classList.remove('dormant-revealed');

          // Hide content (do NOT delete original values)
          el.innerText = '';
          const attrs = ['src', 'href', 'data-link', 'onclick'];
          attrs.forEach(attr => {
            if (el.hasAttribute(attr)) {
              el.removeAttribute(attr);
            }
          });
        }
      });

      attachAllHandlers(doc);
    }





    const dormantBtn = document.createElement('button');
    dormantBtn.textContent = "üëÅÔ∏è Show Dormant";
    dormantBtn.style.position = "fixed";
    dormantBtn.style.bottom = "100px";
    dormantBtn.style.right = "20px";
    dormantBtn.style.width = "130px";
    dormantBtn.style.height = "60px";
    dormantBtn.style.zIndex = "9999";
    dormantBtn.style.padding = "16px 20px";
    dormantBtn.style.background = "linear-gradient(135deg, #a55eea, #8854d0)";
    dormantBtn.style.color = "white";
    dormantBtn.style.border = "none";
    dormantBtn.style.cursor = "pointer";
    dormantBtn.style.fontWeight = "700";
    dormantBtn.style.boxShadow = "0 10px 30px rgba(165, 94, 234, 0.4)";
    dormantBtn.style.transition = "all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275)";
    dormantBtn.style.backdropFilter = "blur(15px)";
    dormantBtn.style.border = "2px solid rgba(255, 255, 255, 0.3)";
    dormantBtn.style.textTransform = "uppercase";
    dormantBtn.style.letterSpacing = "0.5px";
    dormantBtn.style.overflow = "hidden";
    dormantBtn.style.animation = "slideIn 0.6s ease-out 0.4s both";
    dormantBtn.style.clipPath = "polygon(20% 0%, 80% 0%, 100% 50%, 80% 100%, 20% 100%, 0% 50%)";
    dormantBtn.style.transform = "rotate(0deg)";
    document.body.appendChild(dormantBtn);
    let dormantVisible = false;
    dormantBtn.onclick = () => {
      dormantVisible = !dormantVisible;
      showDormantElements(dormantVisible);
      dormantBtn.textContent = dormantVisible ? "üôà Hide Dormant" : "üëÅÔ∏è Show Dormant";
    };


    async function apiCommit(path, contentB64, message) {
      let fileSha = undefined;

      try {
        if (path !== FILE_PATH) {
          // Try to get existing SHA for this file
          const res = await fetch(`https://api.github.com/repos/${USERNAME}/${REPO}/contents/${path}`, {
            headers: { 'Authorization': `Bearer ${TOKEN}` }
          });
          if (res.ok) {
            const data = await res.json();
            fileSha = data.sha;
          }
        } else {
          fileSha = sha; // known from index.html load
        }

        const res = await fetch(`https://api.github.com/repos/${USERNAME}/${REPO}/contents/${path}`, {
          method: 'PUT',
          headers: {
            'Authorization': `Bearer ${TOKEN}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            message,
            content: contentB64,
            sha: fileSha,
            branch: BRANCH
          })
        });

        if (!res.ok) {
          const errorData = await res.json();
          throw new Error(`GitHub API error: ${errorData.message || res.statusText}`);
        }

        return await res.json();
      } catch (error) {
        console.error('API commit failed:', error);
        throw error;
      }
    }



    async function loadHTML() {
      try {
        const r = await fetch(`https://api.github.com/repos/${USERNAME}/${REPO}/contents/${FILE_PATH}`, { 
          headers: { 'Authorization': `Bearer ${TOKEN}` } 
        });
        
        if (!r.ok) {
          throw new Error(`Failed to load file: ${r.status} ${r.statusText}`);
        }
        
        const j = await r.json();
        const html = atob(j.content);
        sha = j.sha;
        frame.srcdoc = html;
      } catch (e) { 
        console.error('Load failed:', e);
        alert('Load failed: ' + e.message);
      }
    }


    frame.onload = () => {
      const doc = frame.contentDocument;
      console.log('Frame loaded, setting up handlers...');
      doc._iframeSpaceHeld = false;
      upgradeAllIframes(doc);
      doc.addEventListener('keydown', ev => { if (ev.code === 'Space') doc._iframeSpaceHeld = true; });
      doc.addEventListener('keyup', ev => { if (ev.code === 'Space') doc._iframeSpaceHeld = false; });
      showDormantElements(dormantVisible);
      attachAllHandlers(doc);
      console.log('Frame setup complete');
      
      // Initialize history with current state
      setTimeout(() => initializeHistory(), 100);
      
      // Start auto-save
      startAutoSave();
      showStatus('üöÄ Editor ready!', 2000, 'success');
    };


    // Save Work functionality (local save)
    const saveWorkBtn = document.getElementById('saveWorkBtn');
    saveWorkBtn.onclick = async () => {
      // Create popup for custom label
      const overlay = document.createElement('div');
      overlay.className = 'edit-overlay';
      const backdrop = document.createElement('div');
      backdrop.className = 'edit-backdrop';
      
      overlay.innerHTML = `
        <h3>üíæ Save Work</h3>
        <p>Enter a label for this saved work:</p>
        <input type="text" id="saveWorkLabel" placeholder="e.g., 'Homepage with new header'" style="width: 100%; padding: 12px; border: 2px solid rgba(255,255,255,0.3); border-radius: 8px; background: rgba(0,0,0,0.8); color: white; font-size: 14px; margin: 10px 0; outline: none;">
        <div class="button-group">
          <button onclick="saveWorkWithLabel()" class="primary">Save Work</button>
          <button onclick="this.closest('.edit-overlay').remove(); this.closest('.edit-backdrop').remove();" class="secondary">Cancel</button>
        </div>
      `;
      
      document.body.append(backdrop, overlay);
      
      // Focus on input
      setTimeout(() => {
        document.getElementById('saveWorkLabel').focus();
      }, 100);
      
      // Close on backdrop click
      backdrop.onclick = () => {
        overlay.remove();
        backdrop.remove();
      };
      
      // Close on Enter key
      document.getElementById('saveWorkLabel').addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          saveWorkWithLabel();
        }
      });
    };
    
    function saveWorkWithLabel() {
      try {
        const label = document.getElementById('saveWorkLabel').value.trim();
        if (!label) {
          showStatus('‚ùå Please enter a label', 2000, 'error');
          return;
        }
        
        const doc = frame.contentDocument || frame.contentWindow.document;
        const htmlContent = doc.documentElement.outerHTML;
        
        // Save to localStorage as temporary work
        const saveKey = `temp_work_${FILE_PATH}_${Date.now()}`;
        const saveData = {
          html: htmlContent,
          timestamp: Date.now(),
          filename: FILE_PATH,
          description: label
        };
        
        localStorage.setItem(saveKey, JSON.stringify(saveData));
        
        // Close popup
        document.querySelectorAll('.edit-overlay, .edit-backdrop').forEach(el => el.remove());
        
        // Show success message
        showStatus(`üíæ Work saved as "${label}"! (Not published to web)`, 3000, 'success');
        
        // Visual feedback
        saveWorkBtn.style.transform = 'scale(1.1)';
        saveWorkBtn.style.boxShadow = '0 15px 40px rgba(40, 167, 69, 0.6)';
        setTimeout(() => {
          saveWorkBtn.style.transform = '';
          saveWorkBtn.style.boxShadow = '';
        }, 300);
        
      } catch (error) {
        console.error('Save work error:', error);
        showStatus('‚ùå Failed to save work', 3000, 'error');
      }
    }

    // Publish to Web functionality
    const publishBtn = document.getElementById('publishBtn');
    publishBtn.onclick = async () => {
      try {
        // Show loading state
        const originalText = commitBtn.textContent;
        const spinner = commitBtn.querySelector('.spinner');
        const commitStatus = document.getElementById('commitStatus');
        
        commitBtn.textContent = '‚è≥ Committing...';
        commitBtn.disabled = true;
        spinner.style.display = 'inline-block';
        commitStatus.style.display = 'block';
        
        // Start progress animation
        showProgress(25);
        showStatus('üîÑ Preparing changes...', 0, 'info');
        
        const doc = frame.contentDocument || frame.contentWindow.document;

        // üîç Temporarily show all dormant content
        const dormantEls = doc.querySelectorAll('.dormant, .dormant-revealed');
        dormantEls.forEach(el => {
          if (el.classList.contains('dormant-revealed')) {
            el.classList.remove('dormant-revealed');
            el.classList.add('dormant');
          }
        });

        // üîê Clean HTML for commit (remove editor-specific elements)
        const cleanDoc = doc.cloneNode(true);
        
        // ‚úÖ Ensure all necessary styles are injected
        const requiredStyles = `
    .dormant {
      display: none !important;
      visibility: hidden !important;
      opacity: 0 !important;
      pointer-events: none !important;
      height: 0 !important;
      width: 0 !important;
      overflow: hidden !important;
    }
    .dormant-revealed {
      opacity: 0.3 !important;
      pointer-events: auto !important;
      outline: 2px dotted #e67e22 !important;
      background: #fffbe6 !important;
      color: #e67e22 !important;
      cursor: pointer !important;
    }
    .editable-form-embed {
      width: 100% !important;
      height: 500px;
      display: block;
      border: none;
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    .iframe-wrapper {
      position: relative;
      display: inline-block;
      overflow: hidden;
    }
    .iframe-overlay {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: transparent;
      z-index: 1000;
      cursor: pointer;
    }`;
        
        const head = cleanDoc.querySelector('head');
        if (head) {
          // Remove any existing editor styles
          cleanDoc.querySelectorAll('style[data-dormant], style[data-editor]').forEach(el => el.remove());
          
          // Add fresh styles
          const style = cleanDoc.createElement('style');
          style.setAttribute('data-editor', 'yes');
          style.textContent = requiredStyles;
          head.appendChild(style);
        }
        
        // Clean up editor-specific elements and convert back to simple iframes
        cleanDoc.querySelectorAll('[data-editor-attached]').forEach(el => {
          el.removeAttribute('data-editor-attached');
        });
        
        // Remove edit buttons and convert wrapped iframes back to simple iframes
        cleanDoc.querySelectorAll('div[style*="position: relative"]').forEach(wrapper => {
          const iframe = wrapper.querySelector('iframe');
          const editButton = wrapper.querySelector('button');
          
          if (iframe) {
            // Get the wrapper's dimensions
            const width = wrapper.style.width || '100%';
            const height = wrapper.style.height || '500px';
            
            // Apply dimensions to iframe
            iframe.style.width = width;
            iframe.style.height = height;
            iframe.style.border = 'none';
            iframe.style.display = 'block';
            iframe.style.margin = '0 auto';
            iframe.style.boxSizing = 'border-box';
            iframe.style.maxWidth = '100%';
            
            // Remove edit button
            if (editButton) {
              editButton.remove();
            }
            
            // Move iframe out of wrapper and remove wrapper
            wrapper.parentNode.insertBefore(iframe, wrapper);
            wrapper.remove();
          }
        });
        

        

        
        // Final cleanup: Remove any remaining editor-specific styles from iframes
        cleanDoc.querySelectorAll('iframe').forEach(iframe => {
          // Remove any editor-specific inline styles
          iframe.style.outline = '';
          iframe.style.transition = '';
          iframe.style.zIndex = '';
          iframe.style.pointerEvents = '';
          
          // Ensure clean styling
          iframe.style.border = 'none';
          iframe.style.display = 'block';
          iframe.style.margin = '0 auto';
          iframe.style.boxSizing = 'border-box';
          iframe.style.maxWidth = '100%';
        });
        
        // üîê Serialize and commit cleaned HTML
        showProgress(75);
        showStatus('üíæ Uploading to GitHub...', 0, 'info');
        
        const newHTML = cleanDoc.documentElement.outerHTML;
        const enc = btoa(unescape(encodeURIComponent(newHTML)));
        await apiCommit(FILE_PATH, enc, 'Commit from editor');
        
        // üîÑ Reload content and restore view
        showProgress(90);
        showStatus('üîÑ Reloading content...', 0, 'info');
        await loadHTML();
        
        // Show success
        showProgress(100);
        showStatus('‚úÖ Successfully committed!', 3000, 'success');
        commitStatus.style.display = 'none';
        commitBtn.textContent = '‚úÖ Committed!';
        spinner.style.display = 'none';
        setTimeout(() => {
          commitBtn.textContent = originalText;
          commitBtn.disabled = false;
        }, 2000);
      } catch (e) {
        console.error('Commit failed:', e);
        alert('Commit failed: ' + e.message);
        
        // Restore button state
        showProgress(0);
        showStatus('‚ùå Commit failed!', 3000, 'error');
        commitStatus.style.display = 'none';
        spinner.style.display = 'none';
        commitBtn.textContent = originalText;
        commitBtn.disabled = false;
      }
    };



    // Initialize page selector and load initial page
    initializePageSelector();
    loadHTML();
    
    // Check for saved work and offer to restore it after a short delay
    setTimeout(() => {
      const savedWork = [];
      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key && key.startsWith('temp_work_') && key.includes(FILE_PATH)) {
          try {
            const data = JSON.parse(localStorage.getItem(key));
            savedWork.push({
              key: key,
              ...data
            });
          } catch (e) {
            console.error('Error parsing saved work:', e);
          }
        }
      }
      
      // If there's saved work, offer to restore it
      if (savedWork.length > 0) {
        savedWork.sort((a, b) => b.timestamp - a.timestamp);
        const mostRecent = savedWork[0];
        
        const overlay = document.createElement('div');
        overlay.className = 'edit-overlay';
        const backdrop = document.createElement('div');
        backdrop.className = 'edit-backdrop';
        
        overlay.innerHTML = `
          <h3>üíæ Restore Saved Work?</h3>
          <p>Found saved work from ${new Date(mostRecent.timestamp).toLocaleString()}</p>
          <p><strong>${mostRecent.description}</strong></p>
          <div class="button-group">
            <button onclick="restoreSavedWork('${mostRecent.key}')" class="primary">Restore</button>
            <button onclick="this.closest('.edit-overlay').remove(); this.closest('.edit-backdrop').remove();" class="secondary">Start Fresh</button>
          </div>
        `;
        
        document.body.append(backdrop, overlay);
        
        backdrop.onclick = () => {
          overlay.remove();
          backdrop.remove();
        };
      }
    }, 1000);
    
    function restoreSavedWork(key) {
      try {
        const data = JSON.parse(localStorage.getItem(key));
        if (data && data.html) {
          frame.srcdoc = data.html;
          frame.onload = () => {
            const doc = frame.contentDocument || frame.contentWindow.document;
            attachAllHandlers(doc);
            showStatus('üíæ Restored saved work!', 3000, 'success');
          };
          
          // Close the dialog
          document.querySelectorAll('.edit-overlay, .edit-backdrop').forEach(el => el.remove());
        }
      } catch (error) {
        console.error('Error restoring saved work:', error);
        showStatus('‚ùå Failed to restore saved work', 3000, 'error');
      }
    }

  </script>
</body>

</html>
